var Mad=function(e){"use strict";class t{constructor(e){this.id=t.getId()}static getId(){return t.id+=1,t.id}}t.id=-1;class r extends t{constructor(e){super(id),this.url=e}}class a{constructor(){this.assetsMap=new Map,this.parsersMap=new Map}registerParser(e,t){if(void 0!==this.parsersMap[e])return console.warn("the parser for",e,"already existed"),!1;this.parsersMap.set(e,t)}unregisterPaser(e){this.parsersMap.set(e,void 0)}getParser(e){e=e.split(".");return this.parsersMap.get(e[e.length-1])}load(e,t,r){var a=new MacroAsset;a.load(e,t,r),this.assetsMap.set(a.id,a)}static getManager(){return null===a.manager&&(a.manager=new a),a.manager}}var i;a.manager=null,i=navigator.userAgent,-1<i.indexOf("Opera")||-1<i.indexOf("Firefox")||-1<i.indexOf("Chrome")||-1<i.indexOf("Safari")||-1<i.indexOf("compatible")&&i.indexOf("MSIE");function l(e,t,r,a){this.x=e,this.y=t,this.z=r,this.w=a,l.prototype.copyFrom=function(e){this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w}}function P(e,t,r){this.x=e,this.y=t,this.z=r,P.prototype.copyFrom=function(e){this.x=e.x,this.y=e.y,this.z=e.z},P.prototype.dot=function(e){return this.x*e.x+this.y*e.y+this.z*e.z},P.prototype.sub=function(e){return new P(this.x-e.x,this.y-e.y,this.z-e.z)},P.prototype.cross=function(e){var t=new P;return t.x=this.y*e.z-this.z*e.y,t.y=this.z*e.x-this.x*e.z,t.z=this.x*e.y-this.y*e.x,t},P.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},P.prototype.normalize=function(){var e=this.length();this.x=this.x/e,this.y=this.y/e,this.z=this.z/e}}class _{static transposeArr(e){return[e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]]}static rotX(e){var t=e*math.pi/180,e=math.cos(t),t=math.sin(t);return math.matrix([[1,0,0,0],[0,e,-t,0],[0,t,e,0],[0,0,0,1]])}static rotY(e){var t=e*math.pi/180,e=math.cos(t),t=math.sin(t);return math.matrix([[e,0,t,0],[0,1,0,0],[-t,0,e,0],[0,0,0,1]])}static rotZ(e){var t=e*math.pi/180,e=math.cos(t),t=math.sin(t);return math.matrix([[e,-t,0,0],[t,e,0,0],[0,0,1,0],[0,0,0,1]])}static scale(e,t,r){return math.matrix([[e,0,0,0],[0,t,0,0],[0,0,r,0],[0,0,0,1]])}static translate(e,t,r){return math.matrix([[1,0,0,e],[0,1,0,t],[0,0,1,r],[0,0,0,1]])}static isPowerOf2(e){return 0==(e&e-1)}static getLength(e,t,r){return e instanceof P?math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z):"number"==typeof e?math.sqrt(e*e+t*t+r*r):e instanceof l?math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w):void 0}static normalize(e){var t=this.getLength(e);return t<1e-10&&console.warn("warning: two small"),new P(e.x/t,e.y/t,e.z/t)}static multiplyV3(e,t){return e instanceof P&&t instanceof P?new P(e.x*t.x,e.y*t.y,e.z*t.z):(console.error("multiplyV3, parameter not Vector3"),null)}static V3MultiNum(e,t){return e instanceof P&&"number"==typeof t?new P(e.x*t,e.y*t,e.z*t):(console.error("V3MutilNum, unidentified parameters",e,t),null)}static V3ADDV3(e){for(var t=new P(0,0,0),r=0;r<arguments.length;r++){if(!(arguments[r]instanceof P))return console.error("V3ADDV3, unsupported parameters",V1,V2),null;t.x+=arguments[r].x,t.y+=arguments[r].y,t.z+=arguments[r].z}return t}static V3SubV3(e,t){return e instanceof P&&t instanceof P?new P(e.x-t.x,e.y-t.y,e.z-t.z):(console.error("V3SubV3, unsupported parameters",e,t),null)}static multiplyMat(e,t){return math.multiply(e,t)}static vec3ToArr(e){return new Float32Array([e.x,e.y,e.z])}static mat2Arr(e){return new Float32Array(math.flatten(math.transpose(e)._data))}static vec3MultiMat4(e,t,r){null==r&&(r=1);r=math.matrix([[e.x],[e.y],[e.z],[r]]),r=math.flatten(math.multiply(t,r));return new l(r._data[0],r._data[1],r._data[2],r._data[3])}static vec4MultiMatrix(e,t){e=math.matrix([[e.x],[e.y],[e.z],[e.w]]),e=math.flatten(math.multiply(t,e));return new l(e._data[0],e._data[1],e._data[2],e._data[3])}static getNormalMatrixArr(e,t){return _.mat2Arr(math.transpose(math.multiply(e,t)))}static isNone(e){if(null==e)return!0}static bucketSortDict(e,t,r,a){for(var i=[],o={},s=r-a+1,n=0;n<s;n++)i[n]=0;for(var l=0;l<e.length;l++){var h=e[l],c=t(h);if(r<c)return console.error("the value excede the maxmum"),null;0!==i[c]?i[c].push(h):i[c]=[h]}for(var u=0;u<s;u++)0!==i[u]&&(o[u]=i[u]);return o}static bucketSort(e,t,r,a){for(var i=[],o=[],s=r-a+1,n=0;n<s;n++)i[n]=0;for(var l=0;l<e.length;l++){var h=e[l],c=t(h);if(r<c)return console.error("the value excede the maxmum"),null;0!==i[c]?i[c].push(h):i[c]=[h]}for(var u=0;u<s;u++)if(0!==i[u])for(var d=0;d<i[u].length;d++)o.push(i[u][d]);return o}}const s={xyz:0,zyx:1};class h{constructor(){this.pos=new P(0,0,0),this.rot=new P(0,0,0),this.scal=new P(1,1,1),this.transformMatrix=math.identity(4,4),this.invTransformMatrix=math.identity(4,4),this.derivTranMatrix=math.identity(4,4),this.derivInvTranMatrix=math.identity(4,4),this.derivGLArray=h.mat2Arr(this.derivTranMatrix),this.derivInvGLArray=h.mat2Arr(this.derivInvTranMatrix),this.rotOrder=s.xyz,this.parent=null,this.children=[],this.dirty(),this.id=h.getId()}static getId(){return h.id+=1,h.id}dirty(){for(var e in this.isDirty=!0,this.children)this.children[e].dirty()}setParent(e){if(null===this.parent||this.parent.id!==tran.id){if(null!==this.parent)for(var t in this.parent.children)this.parent.children[t].id===this.id&&this.parent.children.splice(t,1);(this.parent=e).children.push(this),this.dirty()}}detachParent(){for(var e in this.parent.children)this.parent.children[e].id===this.id&&this.parent.children.splice(e,1);this.dirty()}getParent(){return this.parent}getChildByIndex(e){return this.children[e]}getChilrdren(){return this.children}getCopy(){var e=new h;return e.copyFrom(this),e}copyFrom(e){this.pos.copyFrom(e.pos),this.rot.copyFrom(e.rot),this.scal.copyFrom(e.scal),this.transformMatrix=math.clone(e.transformMatrix),this.invTransformMatrix=math.clone(e.invTransformMatrix),this.derivTranMatrix=math.clone(e.derivTranMatrix),this.derivInvTranMatrix=math.clone(e.derivInvTranMatrix),this.derivGLArray=math.clone(e.derivGLArray),this.derivInvGLArray=math.clone(e.derivInvGLArray),this.dirty()}translate(e,t,r){this.pos.x=this.pos.x+e,this.pos.y=this.pos.y+t,this.pos.z=this.pos.z+r,this.dirty()}setPosition(e,t,r){this.pos.x=e,this.pos.y=t,this.pos.z=r,this.dirty()}scale(e,t,r){this.scal.x=this.scal.x*e,this.scal.y=this.scal.y*t,this.scal.z=this.scal.z*r,this.dirty()}resetScale(e,t,r){this.scal.x=e,this.scal.y=t,this.scal.z=r,this.dirty()}rotate(e,t,r){this.rot.x=this.rot.x+e,this.rot.y=this.rot.y+t,this.rot.z=this.rot.z+r,this.dirty()}lookAt2(e,t,r){var a=this.pos.x-e,i=this.pos.y-t,o=this.pos.z-r,e=Math.sqrt(a*a+i*i+o*o),t=0,r=0;e<Epsilon||(a=a/e,o=o/e,t=-1*Math.asin(i/e)*180/Math.PI,r=(o=Math.sqrt(a*a+o*o))<Epsilon?0:180*Math.asin(a/o)/Math.PI,this.rot.x=t,this.rot.y=r,this.dirty())}lookAt(e,t,r){var a=this.pos.x-e,i=this.pos.y-t,o=this.pos.z-r,e=Math.sqrt(a*a+i*i+o*o),t=0,r=0;e<Epsilon||(t=180*(i=Math.asin(-1*(i/e)))/Math.PI,i=e*Math.cos(i),Math.abs(i)<Epsilon?r=0:(r=180*Math.atan(a/o)/Math.PI,0<=a&&0<=o?r=180*Math.asin(a/i)/Math.PI:0<=a&&o<=0?r=180*Math.acos(o/i)/Math.PI:(a<=0&&o<=0||a<=0&&0<=o)&&(r=180*Math.asin(a/i)/Math.PI+360)),this.rot.x=t,this.rot.y=r,this.dirty())}resetRotate(e,t,r){this.rot.x=e,this.rot.y=t,this.rot.z=r,this.dirty()}resetAll(){this.pos.x=this.pos.y=this.pos.z=0,this.rot.x=this.rot.y=this.rot.z=0,this.scal.x=this.scal.y=this.scal=1,this.dirty()}requireUpdate(){this.dirty()}getRotationMatrix(){var e=null,t=_.rotX(this.rot.x),r=_.rotY(this.rot.y),a=_.rotZ(this.rot.z);return e=this.rotOrder===s.zyx?(e=math.multiply(a,r),math.multiply(e,t)):(e=math.multiply(t,r),math.multiply(e,a))}update(){var e,t,r;this.isDirty&&(t=_.translate(this.pos.x,this.pos.y,this.pos.z),e=this.getRotationMatrix(),r=_.scale(this.scal.x,this.scal.y,this.scal.z),this.transformMatrix=math.multiply(t,e),this.transformMatrix=math.multiply(this.transformMatrix,r),t=_.translate(-1*this.pos.x,-1*this.pos.y,-1*this.pos.z),r=_.scale(1/this.scal.x,1/this.scal.y,1/this.scal.z),this.invTransformMatrix=math.multiply(r,math.transpose(e)),this.invTransformMatrix=math.multiply(this.invTransformMatrix,t),this.calDerivMatrix(),this.derivGLArray=h.mat2Arr(this.derivTranMatrix),this.derivInvGLArray=h.mat2Arr(this.derivInvTranMatrix),this.isDirty=!1)}getTransMatrix(){return this.update(),this.transformMatrix}getInvTransMatrix(){return this.update(),this.invTransformMatrix}getDerivTranMatrix(){return this.update(),this.derivTranMatrix}getDerivInvTranMatrix(){return this.update(),this.derivInvTranMatrix}calDerivMatrix(){var e,t;null!==this.parent?(e=this.parent.getDerivTranMatrix(),t=this.parent.getDerivInvTranMatrix(),this.derivTranMatrix=math.multiply(e,this.transformMatrix),this.derivInvTranMatrix=math.multiply(this.invTransformMatrix,t)):(this.derivInvTranMatrix=math.clone(this.invTransformMatrix),this.derivTranMatrix=math.clone(this.transformMatrix))}static getMVMatrix(e,t){return math.multiply(e,t)}static mat2Arr(e){return new Float32Array(math.flatten(math.transpose(e)._data))}static getMVGLArr(e,t){t=h.getMVMatrix(e,t);return h.mat2Arr(t)}}h.id=0;const c={projectionMatrix:"projectionMatrix",modelViewMatrix:"modelViewMatrix"};function o(e,t){this.loc=e,this.utype=t,this.value=null}function n(){this.vertexColor=null,this.texture0=null,this.depthTest=!0,this.depthWrite=!0,this.enableCull=!0,this.cullFace="BACK",this.castShadow=!1,this.receiveShadow=!1,this.uniformsToUp={},this.useUV=!1,this.IBL=!1}var u={vertexPos:!0,types:{}};function d(){this.vertexPos=-1,this.vertexColor=-1,this.uv=-1,this.vertexNormal=-1,this.vertexTangent=-1}const w={Mat4:"uniformMatrix4fv",Mat3:"uniformMatrix3fv",Vec4:"uniform4fv",Vec3:"uniform3fv",Vec2:"uniform2fv",float:"uniform1f",texture:"uniform1i",vec2i:"uniform2iv",vec3i:"uniform3iv",vec4i:"uniform4iv"};function f(){this.projectionMatrix=new o(null,w.Mat4),this.modelViewMatrix=new o(null,w.Mat4)}function p(e,t,r,a){this.program=e,this.attribLocations=t,this.uniformLocations=r,this.shaderOption=a}class m{constructor(e,t,r,a){this.gl=e,this.shaderProgram=m.initialShaderProgram(e,t,r),this.programInfo=m.createProgramInfo(e,this.shaderProgram,a)}updateUniform(e,t,r){var a=this.programInfo.uniformLocations[e];if(void 0!==a)return a.value=r,!0;a=this.gl.getUniformLocation(this.shaderProgram,e);return null!==a?(this.programInfo.uniformLocations[e]=new o(a,t),this.programInfo.uniformLocations[e].value=r,!0):(console.warn("there is no "+e+"in the complied shader "),!1)}static loadShader(e,t,r){var a=e.createShader(t);if(e.shaderSource(a,r),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS))return a;r=e.getShaderInfoLog(a);return alert("shader complier error type = "+t+" info="+r),e.deleteShader(a),null}static initialShaderProgram(e,t,r){var a=m.loadShader(e,e.VERTEX_SHADER,t);null===a&&console.error("vertex shader got something wrong",t);t=m.loadShader(e,e.FRAGMENT_SHADER,r);null===t&&console.error("fragment shader got something wrong",r);r=e.createProgram();return e.attachShader(r,a),e.attachShader(r,t),e.linkProgram(r),e.getProgramParameter(r,e.LINK_STATUS)?r:(alert("unable to initialize the shader program:"+e.getProgramInfoLog(r)),e.deleteProgram(r),null)}static createProgramInfo(e,t,r){var a,i=new d;for(a in i){var o=e.getAttribLocation(t,a);-1!==o&&null!=o&&(i[a]=o)}var s,n=new f;for(s in n){var l=e.getUniformLocation(t,s);-1!==l&&null!=l&&(n[s].loc=l)}return new p(t,i,n,r)}}const v={everything:0,layers:1,nothing:2},g={Background:10,default:30,transparent:60};function x(e,t,r,a,i){this.gl=e,this.projectionMatrix=t,this.modelViewMatrix=r,this.programInfo=a,this.vertexBuffer=i}class y{static draw_bindAttributes(e){var t,r=e.gl,a=e.vertexBuffer,i=e.programInfo;for(t in i.attribLocations){var o,s,n,l,h,c=a[t];void 0!==c&&!1!==i.shaderOption[t]&&(-1===i.attribLocations[t]||null===i.attribLocations[t]||null===c||(o=c.perVertexSize,s=c.type,n=c.normalize,l=c.stride,h=c.voffset,r.bindBuffer(r.ARRAY_BUFFER,c.id),r.vertexAttribPointer(i.attribLocations[t],o,s,n,l,h),r.enableVertexAttribArray(i.attribLocations[t])))}}static draw_bindUniforms(e){var t=e.gl,r=e.programInfo;t.useProgram(r.program);var a,i=0;for(a in r.uniformLocations){var o=r.uniformLocations[a];o.value instanceof P?o.value=[o.value.x,o.value.y,o.value.z]:o.value instanceof l&&(o.value=[o.value.x,o.value.y,o.value.z,o.value.w]);var s=o.value,n=o.utype;if(n===w.Mat3||n===w.Mat4)t[n](o.loc,!1,s);else if(n===w.texture){if(s.state!==LoadState.loaded)return!1;t.activeTexture(t["TEXTURE"+i]),t.bindTexture(t[s.type],s.glTexture),t.uniform1i(o.loc,i),i+=1}else t[n](o.loc,s)}return!0}static drawRender(e){var t,r=e.gl,a=e.vertexBuffer;y.draw_bindAttributes(e),y.draw_bindUniforms(e)&&(t=a.vertexCount,null!==(e=a.vertexIndices)&&null!==e.id?(r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e.id),r.drawElements(a.primitiveType,t*e.perVertexSize,e.type,0)):r.drawArrays(a.primitiveType,0,t))}}class M{constructor(e){this.transform=new h,this.name=e,this.id=M.createId(),this.mesh=null,this.material=null,this.renderLayer=g.default}copy(e){null===e&&(e=this.name+"copy");e=new M(e);return e.mesh=this.mesh,e.material=this.material,e.transform.copyFrom(this.transform),e}static createId(){return M.id=M.id+1,M.id}setRenderLayer(e){this.renderLayer=e}getRenderLayer(){return this.renderLayer}}const T={default:M.id=0,notClear:1,onlyDepth:2},L={default:0,depth:1,bloom_col2:2};class C{constructor(){this.transform=new h,this.transform.rotOrder=s.zyx,this.projectionMat=null,this.glProjArray=null,this.fov=45,this.near=.1,this.far=100,this.asp=1.7,this.dirty=!0,this.renderMask=v.everything,this.renderLayers=[],this.renderTarget=null,this.depth=50,this.clearColor=[.2,.3,.4,1],this.clearMask=T.default,this.isOrthogonal=!1,this.id=C.createId(),this.type=L.default,this.enable=!0,this.beforeDrawFunc=null,this.afterDrawFunc=null,this.drawMips=!1,this.isGeneral=!1,this.left=-10,this.right=10,this.top=-10,this.bottom=10}static createId(){return M.id=M.id+1,M.id}setFov(e){this.fov=e,this.dirty=!0}setNear(e){this.near=e,this.dirty=!0}setFar(e){this.far=e,this.dirty=!0}setAsp(e){this.asp=e,this.dirty=!0}getNear(){return this.near}getFar(){return this.far}__updatePersp(){var e,t,r;this.dirty&&(r=this.fov*Math.PI/360,e=1/Math.tan(r),t=this.near,r=this.far,this.projectionMat=math.matrix([[e/this.asp,0,0,0],[0,e,0,0],[0,0,(r+t)/(t-r),2*r*t/(t-r)],[0,0,-1,0]]),this.glProjArray=new Float32Array(math.flatten(math.transpose(this.projectionMat)._data)),this.dirty=!1)}__updateOrth(){var e,t,r,a;this.dirty&&(t=(e=this.near*Math.tan(this.fov*Math.PI*.5/180))*this.asp,r=-1*this.far,a=-1*this.near,this.projectionMat=math.matrix([[1/t,0,0,0],[0,1/e,0,0],[0,0,2/(r-a),(-a-r)/(r-a)],[0,0,0,1]]),this.glProjArray=new Float32Array(math.flatten(math.transpose(this.projectionMat)._data)),this.dirty=!1)}switchProjection(e){this.isOrthogonal=e,this.dirty=!0}setFrustrum(e,t,r,a){this.left=e,this.right=t,this.top=r,this.bottom=a,this.isGeneral=!0,this.dirty=!0}__updateGeneral(){var e=this.near,t=this.far,r=this.right,a=this.left,i=this.top,o=this.bottom;this.projectionMat=math.matrix([[2*e/(r-a),0,(r+a)/(r-a),0],[0,2*e/(i-o),(i+o)/(i-o),0],[0,0,(t+e)/(e-t),2*t*e/(e-t)],[0,0,-1,0]]),this.glProjArray=new Float32Array(math.flatten(math.transpose(this.projectionMat)._data)),this.dirty=!1}update(){this.isGeneral?this.__updateGeneral():(this.isOrthogonal&&this.__updateOrth(),this.__updatePersp())}getProjectionMatrix(){return this.update(),this.projectionMat}getViewMatrix(){return this.update(),this.transform.getDerivInvTranMatrix()}getGLProj(){return this.update(),this.glProjArray}addRenderLayer(e){this.renderLayers.push(e)}}class b{static createDefaultCamera(e){void 0===e&&(e=1.77);e=b.createCamera(45,.1,100,e);return e.transform.setPosition(0,0,8),e.name="default_camera",e}static createCamera(e,t,r,a){var i=new C;return i.setFov(e),i.setFar(r),i.setNear(t),i.setAsp(a),i}static createRTCamera(e,t,r,a){var i,o=b.createDefaultCamera(e/t),t=new RenderTexture("Camera",e,t);for(i in o.renderTarget=t,o.type=r,o.renderMask=v.layers,a){var s=a[i];o.addRenderLayer(s)}return o}static createShadowCamera(e,t,r,a){var i=e,o=t,s=i/o,n=60,e=.1,t=100;(r=void 0===r?!0:r)&&(n=170,e=.5,t=100);s=b.createCamera(n,e,t,s),o=new RenderTexture("Camera",i,o);return o.hasColorBuffer=!1,s.renderTarget=o,s.switchProjection(r),s.clearMask=T.onlyDepth,s.name="shadow_camera",s.depth=30,s.type=L.depth,s.renderMask=v.layers,s.addRenderLayer(g.default),s.transform.setPosition(a.x,a.y,a.z),s.transform.lookAt(0,0,0),s}}const N={Default:C.id=0,UseOwn:1};class S{static initCanvas(e,t){e=document.getElementById(e);void 0!==t&&t!==N.Default||(e.width=e.clientWidth,e.height=e.clientHeight);t=e.getContext("webgl",{});return null===(t=null===t?e.getContext("experimental-webgl"):t)&&alert("Unable to initialize the webgl context"),t}}function F(e,t,r){this.id=e,this.type=t,this.perVertexSize=r,this.normalize=!1,this.stride=0,this.voffset=0}class D{constructor(){this.vertexPos=null,this.vertexColor=null,this.vertexIndices=null,this.vertexCount=-1,this.primitiveType=null}}class R{static createBufferParam(e,t,r,a,i){var o=e.createBuffer();e.bindBuffer(i,o);var s=null;if(a===e.FLOAT)s=new Float32Array(t);else{if(a!==e.UNSIGNED_SHORT)return console.error("createBufferParam:error:unspported vertex type:",type),null;s=new Uint16Array(t)}return e.bufferData(i,s,e.STATIC_DRAW),new F(o,a,t.length/r)}static addInfoToVB(e,t,r,a,i,o){return r instanceof Array?(u.types[a]=!0,t[a]=R.createBufferParam(e,r,t.vertexCount,i,o),!0):(console.log("addInfoToVB error: infoName="+a," Arr type should be Array not",typeof r),!1)}static addPos(e,t,r){return R.addInfoToVB(e,t,r,"vertexPos",e.FLOAT,e.ARRAY_BUFFER)}static addColor(e,t,r){return R.addInfoToVB(e,t,r,"vertexColor",e.FLOAT,e.ARRAY_BUFFER)}static addIndices(e,t,r){return R.addInfoToVB(e,t,r,"vertexIndices",e.UNSIGNED_SHORT,e.ELEMENT_ARRAY_BUFFER)}static initVertexBuffer(e,t,r){var a=new D;return a.vertexCount=t,a.primitiveType=null===r?e.TRIANGLE_STRIP:r,a}}const I={TriangularStrip:0,Point:1,LineStrip:2,LineLoop:3,Triangular:4,TriangularFan:5,Line:6};class E{constructor(){this.vertexPos=null,this.vertexColor=null,this.vertexIndices=null,this.vertexNormal=null,this.vertexTangent=null,this.uv=null,this.vertexCount=0,this.primitiveType=I.TriangularStrip,this.vertexBufferInfo=null,this.dirty=!0,this.stateDirty=!0,this.posDirty=!1}setPrimitiveType(e){this.primitiveType=e,this.stateDirty=!0}updateStates(e){this.stateDirty&&(e=E.switchToGLPrimType(e,this.primitiveType),this.vertexBufferInfo.primitiveType=e,this.stateDirty=!1)}updateVertexPosByIndex(e,t){this.vertexPos[e]=t,this.posDirty=!0}updateAllVertexPos(e){this.vertexPos=e,this.vertexCount=e.length/3,this.posDirty=!0}update(e){var t;this.posDirty&&(t=this.vertexBufferInfo.vertexPos.id,e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array(this.vertexPos),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),this.posDirty=!1),this.dirty&&(delete this.vertexBufferInfo,this.vertexBufferInfo=R.initVertexBuffer(e,this.vertexCount),u.types={},null!==this.vertexPos&&R.addPos(e,this.vertexBufferInfo,this.vertexPos),null!==this.vertexColor&&R.addColor(e,this.vertexBufferInfo,this.vertexColor),null!==this.uv&&R.addInfoToVB(e,this.vertexBufferInfo,this.uv,"uv",e.FLOAT,e.ARRAY_BUFFER),null!==this.vertexNormal&&R.addInfoToVB(e,this.vertexBufferInfo,this.vertexNormal,"vertexNormal",e.FLOAT,e.ARRAY_BUFFER),null!==this.vertexIndices&&R.addIndices(e,this.vertexBufferInfo,this.vertexIndices),null!==this.vertexTangent&&R.addInfoToVB(e,this.vertexBufferInfo,this.vertexTangent,"vertexTangent",e.FLOAT,e.ARRAY_BUFFER),this.updateStates(e),this.dirty=!1)}getVertexBufferInfo(e){return this.update(e),this.updateStates(e),this.vertexBufferInfo}static switchToGLPrimType(e,t){var r=e.TRIANGLE_STRIP;switch(t){case I.TriangularStrip:break;case I.LineStrip:r=e.LINE_STRIP;break;case I.LineLoop:r=e.LINE_LOOP;break;case I.Triangular:r=e.TRIANGLES;break;case I.TriangularFan:r=e.TRIANGLE_FAN;break;case I.Point:r=e.POINTS;break;case I.Line:r=e.LINES}return r}static createFromArray(e,t,r=null){var a=new E;return a.vertexCount=e,a.vertexPos=t,a.vertexColor=r,a}}class A extends E{constructor(e){super(),this.w=void 0===e.w?1:e.w,this.h=void 0===e.h?1:e.h,this.m=void 0===e.m?2:e.m,this.n=void 0===e.n?2:e.n}}const U={xy:0,xz:1};class B{static createMDWelcomeMesh(){var e=Mesh.createFromArray(5,[1,1,0,-1,1,0,1,-1,0,-1,-1,0,-1.5,-1.2,0],[1,1,1,1,.5,.5,.6,1,.7,.7,.7,1,1,1,.3,1,.1,.1,.2,1]);return e.setPrimitiveType(PrimitiveType.TriangularStrip),e}static createCameraPlane(e,t){var r=Math.PI*e.fov/360,a=2*Math.tan(r)*e.near,r=a*e.asp,e=-e.near;return B.createColorPlane(r,a,t,e)}static createPlane(e,t,r,a,i){var o=.5,s=.5,n=0;"number"==typeof e&&(o=e/2),"number"==typeof t&&(s=t/2),"number"==typeof r&&(n=r);t=null,r=[0,0,1];i===U.xz?(t=[-o,n,s,o,n,s,o,n,-s,-o,n,-s],r=[0,1,0]):t=[-o,-s,n,o,-s,n,o,s,n,-o,s,n];r=[r[0],r[1],r[2],r[0],r[1],r[2],r[0],r[1],r[2],r[0],r[1],r[2]],t=Mesh.createFromArray(4,t,null);return t.setPrimitiveType(PrimitiveType.TriangularFan),t.uv=[0,0,1,0,1,1,0,1],t.vertexNormal=r,a&&(t.vertexTangent=[1,0,0,1,0,0,1,0,0,1,0,0]),t}static _pushLineIndices(e,t,r,a,i,o,s){o<=t||o<=a||s<=r||s<=i||(console.log(t*o+r,a*o+i),e.push(t*o+r,a*o+i))}static createGridMesh(e,t,r,a,i,o,s=!1){var n=1,l=1,h=0;"number"==typeof i&&(h=i);var c=(l="number"==typeof a?a:l)/(e=void 0===e?2:e),u=(n="number"==typeof r?r:n)/(t=void 0===t?2:t),d=-n/2,f=-l/2;console.log("space",c,u,e,t);for(var p=[],m=[],v=[],g=[],x=[0,0,1],y=0;y<=e;y++)for(var M=f+c*y,T=0;T<=t;T++){var L=d+u*T;p.push(L,h,M),console.log("posx,posz",L,M),m.push(c*y/n,u*T/l),v.push(x[0],x[1],x[2]),o&&g.push(1,0,0)}var w=[],C=e+1;if(s)for(var P=0;P<e+1;P++)for(var _=0;_<t+1;_++)B._pushLineIndices(w,P,_,P,_+1,e+1,t+1),B._pushLineIndices(w,P,_,P+1,_+1,e+1,t+1),B._pushLineIndices(w,P,_,P+1,_,e+1,t+1);else for(P=0;P<e;P++)for(_=0;_<t;_++)w.push(P*C+_,(P+1)*C+_+1,P*C+_+1),w.push(P*C+_,(P+1)*C+_,(P+1)*C+_+1);console.log("indices",w);a=new GridMesh({w:r,h:a,m:e,n:t});return a.vertexCount=(e+1)*(t+1),a.vertexIndices=w,a.vertexPos=p,s?(console.log("isline>>>>>"),a.setPrimitiveType(PrimitiveType.Line)):(console.log("triangel>>>>>"),a.setPrimitiveType(PrimitiveType.Triangular)),a.uv=m,a.vertexNormal=v,o&&(a.vertexTangent=g),a}static createColorPolygon(e,t,r){r=Mesh.createFromArray(r.length/3,r,null);return r.setPrimitiveType(PrimitiveType.Triangular),r.vertexColor=e,r.vertexIndices=t,r}static createColorPlane(e,t,r,a){var a=B.createPlane(e,t,a),i=a.vertexCount,o=null;if((r=void 0===r?[.5,.6,.8,1]:r).length==4*i)o=r;else for(var o=[],s=0;s<i;s++)Array.prototype.push.apply(o,r);return a.vertexColor=o,a}static createBox(e,t,r,a,i){var o=.5,s=.5,n=.5,l=[-(o="number"==typeof e?e/2:o),-(s="number"==typeof t?t/2:s),n="number"==typeof r?r/2:n,o,-s,n,o,s,n,-o,s,n,-o,-s,-n,-o,s,-n,o,s,-n,o,-s,-n,-o,s,-n,-o,s,n,o,s,n,o,s,-n,-o,-s,-n,o,-s,-n,o,-s,n,-o,-s,n,o,-s,-n,o,s,-n,o,s,n,o,-s,n,-o,-s,-n,-o,-s,n,-o,s,n,-o,s,-n];if(void 0!==i)for(var h=e*i[0],c=t*i[1],u=r*i[2],d=0;d<24;d++)l[3*d]-=h,l[3*d+1]-=c,l[3*d+2]-=u;var f=Mesh.createFromArray(24,l,null);if(f.vertexIndices=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23],f.uv=[0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1],f.vertexNormal=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0],f.setPrimitiveType(PrimitiveType.Triangular),a){var p=[1,0,0,-1,0,0,1,0,0,1,0,0,0,0,-1,0,0,1];for(d in f.vertexTangent=[],p)for(var m=0;m<4;m++)f.vertexTangent.push(p[d])}return f}static createColorBox(e,t,r,a){var i,r=B.createBox(e,t,r),o=null,s=[];for(i in o=a instanceof Array?a:[[.8,.8,.8,1],[.7,.4,.4,1],[.55,.7,.35,1],[.3,.3,.7,1],[.7,.7,.3,1],[.7,.35,.65,1]])for(var n=o[i],l=0;l<4;l++)Array.prototype.push.apply(s,n);return r.vertexColor=s,r}static createSphereIndices(e,t,r,a){var i,o;0<e&&(0===t?a.push(o=(e-1)*r+t,e*r+t,o+1):t===r-1?a.push(e*r+t-1,e*r+t,(e-1)*r+t):(o=(i=(e-1)*r+t)+1,a.push((t=e*r+t)-1,t,i),a.push(i,t,o)))}static createSphere(e,t,r,a){void 0===e&&(e=1),void 0===t&&(t=20),void 0===r&&(r=20);for(var i=[],o=[],s=[],n=[],l=[],h=0;h<t;h++){var c=h/(t-1);c*=Math.PI;for(var u=0;u<r;u++){var d=(1-2*(d=u/(r-1)))*Math.PI,f=Math.cos(c),p=Math.sin(c)*Math.cos(d),m=Math.sin(c)*Math.sin(d);s.push(p*e,f*e,m*e),o.push(p,f,m),i.push(u/(r-1),1-h/(t-1)),a&&(m=Math.cos(d),d=Math.sin(d),l.push(d,0,m)),B.createSphereIndices(h,u,r,n)}}var v=Mesh.createFromArray(t*r,s,null);return v.uv=i,v.vertexNormal=o,v.vertexIndices=n,a&&(v.vertexTangent=l),v.setPrimitiveType(PrimitiveType.Triangular),v}static createDoughnuts(e,t,r,a){void 0===r&&(r=20),void 0===a&&(a=20);for(var i=[],o=[],s=[],n=[],l=((t=void 0===t?1:t)-(e=void 0===e?.7:e))/2,h=0;h<r;h++)for(var c=2*(c=h/(r-1))*Math.PI,u=0;u<a;u++){var d=2*(d=u/(a-1))*Math.PI,f=Math.sin(c)*l,p=Math.cos(c)*l+l+e,m=p*Math.cos(d),p=p*Math.sin(d);s.push(m,f,p);m=m-(e+l)*Math.cos(d),f=f,p=p-(e+l)*Math.sin(d),d=_.getLength(m,f,p);o.push(m/d,f/d,p/d),i.push(u/(a-1),h/(r-1)),B.createSphereIndices(h,u,a,n)}t=Mesh.createFromArray(r*a,s,null);return t.uv=i,t.vertexNormal=o,t.vertexIndices=n,t.setPrimitiveType(PrimitiveType.Triangular),t}static createCircle(e,t){void 0===e&&(e=1),void 0===t&&(t=30);var r=[],a=[],i=[];r.push(0,0,0),i.push(.5,.5),a.push(0,1,0);for(var o=[],s=0;s<t;s++){var n=s/t*Math.PI*2,l=Math.sin(n),n=Math.cos(n);r.push(e*l,0,e*n),a.push(0,1,0),i.push(.5*l+.5,.5*n+.5),0<s&&o.push(0,s,s+1)}o.push(0,t,1);var h=Mesh.createFromArray(t+1,r,null);return h.uv=i,h.vertexNormal=a,h.vertexIndices=o,h.setPrimitiveType(PrimitiveType.Triangular),h}static createTaper(e,t,r){for(var a=[],i=[],o=[],s=0;s<r;s++){var n=(n=s/r)*Math.PI*2;a.push(0,e,0),i.push(.5,.5);var l=Math.cos(n),h=Math.sin(n);a.push(t*h,0,t*l);var c=.5*l+.5,u=.5*h+.5;i.push(u,c);var d=s+1,f=(f=(d=s==r-1?0:d)/r)*Math.PI*2,p=Math.cos(f),m=Math.sin(f);a.push(t*m,0,t*p);var v=.5*p+.5,g=.5*m+.5;i.push(g,v);for(var x=.5*(m-h)+h,n=.5*(p-l)+l,d=new P(x,0,n),f=new P(x,0-e,n),f=_.normalize(f),n=x*f.x+n*f.z,y=d.x-f.x*n,M=d.y-f.y*n,T=d.z-f.z*n,L=0;L<3;L++)o.push(y,M,T);a.push(t*m,0,t*p),a.push(t*h,0,t*l),a.push(0,0,0),i.push(g,v),i.push(u,c),i.push(.5,.5);for(var w=0;w<3;w++)o.push(0,-1,0)}console.log(a);var C=Mesh.createFromArray(6*r,a,null);return C.uv=i,C.vertexNormal=o,C.setPrimitiveType(PrimitiveType.Triangular),C}static createTaper_origin(e,t,r,a){for(var i=[],o=[],s=[],n=[],l=0;l<r;l++){for(var h=l/(r-1),c=0;c<a;c++){var u=c/(a-1),d=2*u*Math.PI,f=(1-h)*e,p=t*f/e,m=p*Math.cos(d),p=p*Math.sin(d);i.push(p,f,m),o.push(u,h);d=new P(p,0,m),u=_.normalize(p,f-e,m),f=p*u.x+m*u.z,p=d.x-u.x*f,m=d.y-u.y*f,f=d.z-u.z*f;s.push(p,m,f),B.createSphereIndices(l,c,a,n)}console.log(i);var v=Mesh.createFromArray(r*a,i,null);return v.uv=o,v.vertexNormal=s,v.vertexIndices=n,v.setPrimitiveType(PrimitiveType.Triangular),v}}static createLine(e,t){var r=e.length/3,t=Mesh.createFromArray(r,e,t);return t.setPrimitiveType(PrimitiveType.LineStrip),t}}class V{constructor(){this.transform=new h,this.color=new P(1,1,1),this.specular=new P(1,1,1),this.shininess=10,this.id=V.createId(),this.shadowCam=null,this.castShadow=!1,this.shadowBias=1e-5,this.shadowSmoothStep=.002}static createId(){return V.id=V.id+1,V.id}}V.id=0;class z extends V{constructor(){super()}}class O extends V{constructor(){super(),this.constant=1,this.linear=.01,this.quadratic=1e-4}}class G{static createShadowLight(e,t,r,a,i){var o=null;return i?((o=new O).transform.setPosition(r.x,r.y,r.z),o.constant=.95,o.linear=.07,o.quadratic=.001):(i=!1,(o=new z).transform.setPosition(r.x,r.y,r.z)),a&&(r=b.createShadowCamera(e,t,!i,r),o.castShadow=!0,o.shadowCam=r,e=1/e*2.5,o.shadowBias=1e-5,o.shadowSmoothStep=e),o}}class k{constructor(e,t){this.material=e,this.targetType=L.default,this.targetCam=null,this.setTarget(t)}setTarget(e){_.isNone(e)?this.targetType=L.default:e instanceof C?(this.targetCam=e,this.targetType=e.type):this.targetType=e}getActive(e,t){null!==this.targetCam?t(this.material,this.targetCam):t(this.material,e)}}class X{constructor(e,t){this.subList=[new k(e,t)],this.loop=1}getActive(e,t){for(var r=0;r<this.loop;r++)for(var a in this.subList)this.subList[a].getActive(e,t)}}class H{setTarget(e){_.isNone(e)?this.targetType=L.default:e instanceof C?(this.targetCam=e,this.targetType=e.type):this.targetType=e}constructor(e,t){this.passList=[new X(e,t)],this.targetType=L.default,this.targetCam=null,this.setTarget(t)}add(e,t,r){var a=this.passList.length;if(a<r)return console.error("out of index range,length=",a,"index=",r),!1;r==a?this.passList.push(new X(e,t)):this.passList[r].subList.push(new k(e,t))}getActive(e,t){for(var r in this.passList)this.passList[r].getActive(e,t)}}function j(e,t,r){this.key=e,this.type=t,this.value=r,this.dirty=!0}class q{constructor(){this.texMatMap={}}onTexLoaded(e){if(e.state===LoadState.loaded){var t=this.texMatMap[e.getId()];if(!_.isNone(t)){for(var r=0;r<t.length;r++)t[r].onTexLoaded(e);e.url}e.onLoaded(e)}}static getManager(){return null===q.manager&&(q.manager=new q),q.manager}}q.manager=null;class W{constructor(){this.shaderOption=new n,this.id=W.createId(),this.fsource=null,this.vsource=null,this.program=null,this.dirty=!0,this.matUniList={},this.uDirty=!0,this.loadedCallBack=null,this.texList=[],this.texLoadedCount=0,this.passLayers=[new H(this,L.default)],this.texPrepared=!1}updateUnis(e){if(this.uDirty){for(var t in this.matUniList){var r=this.matUniList[t];r.dirty&&(this.program.updateUniform(r.key,r.type,r.value),this.matUniList[t].dirty=!1)}this.uDirty=!1}}setUniform(e,t,r){e in this.matUniList?(this.matUniList[e].type=t,this.matUniList[e].value=r,this.matUniList[e].dirty=!0):this.matUniList[e]=new j(e,t,r),this.uDirty=!0}update(e){this.dirty&&(this.dirty=!1,delete this.program,this.program=new m(e,this.vsource,this.fsource,this.shaderOption),this.loadTexs(e)),this.uDirty&&this.updateUnis(e)}onTexLoaded(e){this.texLoadedCount+=1,this.texLoadedCount===this.texList.length&&(null!==this.loadedCallBack&&(this.loadedCallBack(this.texList),console.log("material finished loading")),this.texPrepared=!0)}loadTexs(e){for(var t in this.texList){t=this.texList[t];t.state===LoadState.init&&t.loadTexture(e,function(e){q.getManager().onTexLoaded(e)})}}addTexture(e){var t=q.getManager(),r=e.getId();void 0===t.texMatMap[r]&&(t.texMatMap[r]=[]),t.texMatMap[r].push(this),this.texList.push(e)}getProgramInfo(e){return this.update(e),this.program.programInfo}static createId(){return W.id=W.id+1,W.id}setLightShadowParams(e,t){this.setUniform("depthMap["+t+"]",w.texture,e.shadowCam.renderTarget),this.addTexture(e.shadowCam.renderTarget),this.setUniform("biasStep["+t+"]",w.Vec2,[e.shadowBias,e.shadowSmoothStep])}getActive(e,t){if(1!==this.passLayers.length){for(var r in this.passLayers){r=this.passLayers[r];if(r.targetType===e.type)return void(_.isNone(r.targetCam)?r.getActive(e,t):r.getActive(r.targetCam,t))}this.passLayers[0].getActive(e,t)}else this.passLayers[0].getActive(e,t)}addPassLayer(e,t){this.passLayers.push(new H(e,t))}}var Y=W.id=0,K=1,Q=2,Z="UNSIGNED_BYTE",J="FLOAT",$="TEXTURE_2D",ee="RGBA",te="RGB",re="CLAMP_TO_EDGE",ae="Camera";const ie={Add:1,multi:2};class oe{constructor(e){this.url=e,this.type=$,this.elType=Z,this.format=ee}load(r){var a,t,i=this;0<=this.url.indexOf(".hdr")?((a=new XMLHttpRequest).open("GET",this.url,!0),a.responseType="arraybuffer",a.crossOrigin="anonymous",i.elType=J,i.format=te,a.onload=function(e){var t=a.response;t&&(t=new RGBEParser(i.elType).parse(t),i.width=t.width,i.height=t.height,r&&r(i,t.data))},a.send()):((t=new Image).crossOrigin="anonymous",t.onload=function(e){i.width=t.width,i.height=t.height,r&&r(i,t)},t.src=this.url)}}class se{constructor(e,t,r,a){this.url=e,this.glTexture=null,this.state=Y,this.cubeMapHint=null,this.width=t,this.height=r,this.elType=Z,this.format=ee,this.hasMipMap=!0,this.wrap_mode=re,_.isNone(a)?this.type="TEXTURE_2D":this.type=a,_.isNone(t)&&(this.width=1),_.isNone(r)&&(this.height=1),this.id=se.createId(),console.log("constructor:texture >>>id=",this.id,"url=",this.url),this.onLoadedCalls=[],this.mipCount=-1}getId(){return this.id}getMipCount(){return 1===this.width&&1===this.height?(console.error("Texture: not initialized ,url=",this.url),-1):(-1===this.mipCount&&(e=this.width<this.height?this.width:this.height,this.mipCount=Math.log(e)*Math.LOG2E),this.mipCount);var e}static createId(){return se.id=se.id+1,se.id}onLoaded(){for(var e in this.onLoadedCalls)this.onLoadedCalls[e](this)}bindDefaultColor(e,t,r,a,i){"TEXTURE_2D"===this.type&&(null===this.glTexture&&(this.glTexture=e.createTexture()),i=new Uint8Array([255*t,255*r,255*a,255*i]),se.uploadTextureData(e,this,i,!1,!1,1,1))}static uploadTextureData(e,t,r,a,i,o,s){var n=e.RGBA,l=n=!_.isNone(t.format)?e[t.format]:n,h=t.width,c=t.height;_.isNone(o)||(h=o),_.isNone(s)||(c=s);var u=e[t.elType],s=e[t.type];if(console.log("upload Tex,",t.elType),e.bindTexture(s,t.glTexture),t.elType===J&&(f=e.getExtension("OES_texture_float"),console.log("support >> OES_texture_float",f),f=e.getExtension("OES_texture_float_linear"),console.log("support >> OES_texture_float_linear",f),t.wrap_mode=re),s===e.TEXTURE_CUBE_MAP){e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1);for(var d=0;d<6;d++)null===r?e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+d,0,l,h,c,0,n,u,null):r[d]instanceof Image?e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+d,0,l,n,u,r[d]):e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+d,0,l,h,c,0,n,u,r[d])}else r instanceof Image?(e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,a),e.texImage2D(e.TEXTURE_2D,0,l,n,u,r)):(e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,a),e.texImage2D(e.TEXTURE_2D,0,l,h,c,0,n,u,r));e.texParameteri(s,e.TEXTURE_WRAP_S,e[t.wrap_mode]),e.texParameteri(s,e.TEXTURE_WRAP_T,e[t.wrap_mode]),e.LINEAR;var f=!0;t.elType===J&&(a=e.getExtension("OES_texture_float"),p=e.getExtension("OES_texture_float_linear"),void 0!==a&&void 0!==p||(f=!1,alert("not supported")));var p=_.isPowerOf2(t.width)&&_.isPowerOf2(t.height);i&&t.hasMipMap&&p&&(t.elType===J?f&&(e.generateMipmap(s),"Chrome"===MDBrowser?(e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_NEAREST),console.log("Texture>>>>chrome>> use mipmap filter",t.id)):e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.LINEAR)):(e.generateMipmap(s),e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),console.log("Texture>>>>>not chrome >> 3333",t.id))),p||e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST),e.bindTexture(s,null)}static loadCubeTexture(r,a,i){null===a.glTexture&&(a.glTexture=r.createTexture()),a.state=K;for(var o=0,s={},e=0;e<6;e++){var t=a.url[e],t=new oe(t);t.index=e,t.load(function(e,t){o+=1,s[e.index]=t,6===o&&(a.width=e.width,a.height=e.height,a.format=e.format,a.elType=e.elType,se.uploadTextureData(r,a,s,!0,!0),a.state=Q,i(a))})}}static loadNullTexture(e,t,r){null===t.glTexture&&(t.glTexture=e.createTexture()),t.state=K,se.uploadTextureData(e,t,null,!1,!0)}loadTexture(r,a){var i,o=this;o.url===ae||_.isNone(o.url)?se.loadNullTexture(r,o,a):o.url instanceof Array?se.loadCubeTexture(r,o,a):(null===o.glTexture&&(o.glTexture=r.createTexture()),o.state=K,i=this,new oe(o.url).load(function(e,t){i.width=e.width,i.height=e.height,i.format=e.format,i.type=e.type,i.elType=e.elType,se.uploadTextureData(r,i,t,!0,!0),i.state=Q,a(o)}))}}se.id=0;const ne=`void main(){
`,le=`
    varying vec3 skyPos;
`,he=`
    skyPos =inPos.xyz;
  `,ce=`
    for(int jr=0; jr<lightShadowCount; jr++){
        lightSpacePos[jr] = lightPVM[jr]*inPos;
    }
`;const ue=`
const float PI = 3.14159;
float VanDerCorpus(int n, int base)
{
    float invBase = 1.0 / float(base);
    float denom   = 1.0;
    float result  = 0.0;

    for(int i = 0; i < 32; ++i)
    {
        if(n > 0)
        {
            denom   = mod(float(n), 2.0);
            result += denom * invBase;
            invBase = invBase / 2.0;
            n       = int(float(n) / 2.0);
        }
    }

    return result;
}
vec2 Hammersley(int i, int N)
{
    return vec2(float(i)/float(N), VanDerCorpus(i, 2));
}

vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)
{
    float a = roughness*roughness;
	
    float phi = 2.0 * PI * Xi.x;
    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
	
    // from spherical coordinates to cartesian coordinates
    vec3 H;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;
	
    // from tangent-space vector to world-space sample vector
    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent   = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);
	
    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;
    return normalize(sampleVec);
} 
float geometryGGX(float NoV,float NoL,float a){
    float a2 = a * a;
    float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
    float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
    return 0.5 / (GGXV + GGXL);
}
float distributionGGX(float nh,float rough){
    float a = rough*rough;
    float a2 = a*a;
    float f = (nh * a2 - nh) * nh + 1.0;
    float denom = PI*f*f;
    return a2/denom;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    // note that we use a different k for IBL
    float a = roughness;
    float k = (a * a) / 2.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / denom;
}
float GeometrySmith(float NdotV, float NdotL, float roughness)
{
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}
`;class de{static createFromShader(e,t){var r=new W;return r.fsource=t,r.vsource=e,r}static getDefineStr(e,t){return"\n #define "+e+" "+t+"\n"}static createShaderHead(e){var t,r,a=`
    attribute vec4 vertexPos;
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    `,i=`
precision mediump float;
`;return i+=`
#define saturate(a) clamp( a, 0.0, 1.0 )
`,e.useUV&&(a+=`
attribute vec2 uv;
varying vec2 vUV;
`,i+=`
    varying vec2 vUV;
`),_.isNone(e.uvTran)||(i+=`
uniform vec4 uvTran;
`),_.isNone(e.normalMap)?_.isNone(e.modelNormalMap)?(a+=`
    attribute vec3 vertexNormal;
    uniform mat4 normalMatrix;
    varying vec3 vNormal;
`,i+=`
    varying vec3 vNormal;
`):i+=`
    uniform mat4 normalMatrix;
    uniform sampler2D modelNormalMap;
`:(a+=`
    attribute vec3 vertexTangent;
    attribute vec3 vertexNormal;
    varying mat3 TBN;
`,i+=`
    uniform mat4 normalMatrix;
    uniform sampler2D normalMap;
    varying mat3 TBN;
`),_.isNone(e.texture0)?_.isNone(e.vertexColor)?_.isNone(e.cubeMap)?_.isNone(e.rectSphereMap)?_.isNone(e.matColor)||(i+=`
uniform vec4 matColor;
`):(a+=le,i+=`
    uniform sampler2D rectSphereMap;
    varying vec3 skyPos;
    const vec2 invAtan = vec2(0.1591,0.3183);
    vec2 samplerSphericalMap(vec3 dir){
        vec2 uv = vec2(atan(dir.z,dir.x),asin(dir.y));
        uv *= invAtan;
        uv += 0.5;
        return uv;
    }
`):(a+=le,i+=`
    uniform samplerCube cubeMap;
    varying vec3 skyPos;
`):(a+=`
  attribute vec4 vertexColor;
  varying lowp vec4 vColor;
`,i+=`
varying lowp vec4 vColor;
`):i+=`
uniform sampler2D texture0;
`,_.isNone(e.texture1)||(i+=`
uniform sampler2D texture1;
`),_.isNone(e.heightMap)||(a+=`
uniform mat4 modelViewInv;
//varying vec3 tanCamPos;
//varying vec3 tanfragPos;
varying vec3 tanViewDir;
uniform sampler2D heightMap;
mat3 transposeDiv(mat3 mat){
    return mat3(mat[0][0],mat[0][1],mat[0][2],
        mat[1][0],mat[1][1],mat[1][2],
        mat[2][0],mat[2][1],mat[2][2]);
}

`,i+=`
uniform sampler2D heightMap;
const float bumpScale = 1.0;
 //varying vec3 tanCamPos;
 //varying vec3 tanfragPos;
 varying vec3 tanViewDir;
`),_.isNone(e.hdrExposure)||(i+=`
uniform float hdrExposure; 

vec3 LinearToneMapping( vec3 color ) {
	return hdrExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= hdrExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color, float toneMappingWhitePoint ) {
	color *= hdrExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= hdrExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	color *= hdrExposure;
	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );
}
vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }
`),_.isNone(e.lightBlur)||(i+=`
uniform sampler2D  texture_brighter;
`),e.calRadiance&&(i+=`
const float samplerDelta = 0.1;
	const float PI = 3.14159;
	void calIrradiance(inout vec3 irradiance,vec3 N){
		float samples = 0.0;
		vec3 up = vec3(0,1,0);
		vec3 right = cross(up,N);
		up = cross(N,right);
		for(float cita = 0.0; cita<PI*2.0; cita+=samplerDelta){
			for(float phi = 0.0; phi<PI*0.5; phi+=samplerDelta){
				float sinphi = sin(phi);
				float cosphi = cos(phi);
				float coscita =cos(cita);
				float sincita = sin(cita);
				vec3 sampDir = vec3(sinphi*coscita,sinphi*sincita,cosphi);
				//to world space
				vec3 wDir=sampDir.x*right+sampDir.y*up+sampDir.z*N;
                irradiance +=textureCube(cubeMap,wDir).rgb*sinphi*cosphi;
                samples+=1.0;
			}
        }
        irradiance =irradiance*(PI/samples);
	}
`),e.calBrdf&&(i+=ue,i+=`

vec2 IntegrateBRDF(float NdotV, float roughness)
{
    vec3 V;
    V.x = sqrt(1.0 - NdotV*NdotV);
    V.y = 0.0;
    V.z = NdotV;

    float A = 0.0;
    float B = 0.0; 

    vec3 N = vec3(0.0, 0.0, 1.0);
    
    const int SAMPLE_COUNT = 1024;
    for(int i = 0; i < SAMPLE_COUNT; ++i)
    {
        // generates a sample vector that's biased towards the
        // preferred alignment direction (importance sampling).
        vec2 Xi = Hammersley(i, SAMPLE_COUNT);
        vec3 H = ImportanceSampleGGX(Xi, N, roughness);
        vec3 L = normalize(2.0 * dot(V, H) * H - V);

        float NdotL = max(L.z, 0.0);
        float NdotH = max(H.z, 0.0);
        float VdotH = max(dot(V, H), 0.0);
       
        if(NdotL > 0.0)
        {
            float NdotV  = max(dot(N,V),0.0);
            float G = GeometrySmith(NdotV,NdotL,roughness);
            float G_Vis = (G * VdotH) / (NdotH * NdotV);
            float Fc = pow(1.0 - VdotH, 5.0);

            A += (1.0 - Fc) * G_Vis;
            B += Fc * G_Vis;
        }
    }
    A /= float(SAMPLE_COUNT);
    B /= float(SAMPLE_COUNT);
    return vec2(A, B);
}

vec2 IntegrateBRDF2(float NdotV, float roughness)
{
    vec3 V;
    V.x = sqrt(1.0 - NdotV*NdotV);
    V.y = 0.0;
    V.z = NdotV;

    float A = 0.0;
    float B = 0.0;

    vec3 N = vec3(0.0, 0.0, 1.0);

    const int SAMPLE_COUNT = 1024;
    for(int i = 0; i < SAMPLE_COUNT; ++i)
    {
        vec2 Xi = Hammersley(i, SAMPLE_COUNT);
        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);
        vec3 L  = normalize(2.0 * dot(V, H) * H - V);

        float NdotL = max(L.z, 0.0);
        float NdotH = max(H.z, 0.0);
        float VdotH = max(dot(V, H), 0.0);
        float NdotV = max(dot(N,V),0.0);

        if(NdotL > 0.0)
        {
            float G = geometryGGX(NdotV, NdotL, roughness);
            float G_Vis = (G * VdotH) / (NdotH * NdotV);
            float Fc = pow(1.0 - VdotH, 5.0);

            A += (1.0 - Fc) * G_Vis;
            B += Fc * G_Vis;
        }
    }
    A /= float(SAMPLE_COUNT);
    B /= float(SAMPLE_COUNT);
    return vec2(A, B);
}

`),e.calIBLSpec&&(i+=ue,i+=`
uniform float roughness;
`),_.isNone(e.diffuse)||(a+=`
varying vec4 viewPos;
`,i+=`
uniform vec3 ambientLight;
varying vec4 viewPos;

`,_.isNone(e.envMap)||(_.isNone(e.normalMap)?(a+=`
uniform samplerCube cubeMap;
uniform mat4 viewMatrix;
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
`,i+=`

uniform samplerCube cubeMap;
`,_.isNone(e.reflective)||(a+=`
varying vec3 skyPos;
`,i+=`
uniform float reflective;
varying vec3 skyPos;
`),_.isNone(e.refractParams)||(a+=`
    uniform vec2 refractParams; //strength, refractRatio
    varying vec4 refractR;
  `,i+=`
varying vec4 refractR;
`)):(i+=`
uniform samplerCube cubeMap;
uniform mat4 viewMatrix;
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
`,_.isNone(e.reflective)||(i+=`
uniform float reflective;
`),_.isNone(e.refractParams)||(i+=`
uniform vec2 refractParams; // refractRatio,strength
`))),_.isNone(e.aoMap)||(i+=`
uniform sampler2D aoMap;
`),e.PBR?(i+=`
#define PI 3.14159
uniform float roughness;
uniform float metalness;
float rough = 1.0;
float metal = 1.0;
float ao = 1.0;
vec3 F0 = vec3(0.02, 0.02, 0.02);
//uniform vec3 F0;
struct Light{
    vec3 diffuse;
};

float distributionGGX(float nh,float a){
    float a2 = a*a;
    float f = (nh * a2 - nh) * nh + 1.0;
    float denom = PI*f*f;
    return a2/denom;
}
float calDirK(){
    float a2 = (rough+1.0);
    a2 =a2*a2;
    return a2/8.0;
}
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / denom;
}
float geometrySub(float nv, float k){
    return nv/(nv*(1.0-k)+k);
}

float geometryGGX(float NoV,float NoL,float rough){
    float ggx2 = GeometrySchlickGGX(NoV, roughness);
    float ggx1 = GeometrySchlickGGX(NoL, roughness);
    return ggx1 * ggx2;
}

vec3 fresnelReflect(vec3 f0,float VoH){
    return f0 + (vec3(1.0) - f0) * pow(1.0 - VoH, 5.0);
}
void calLight(inout vec3 lcolor, inout vec3 spec, vec3 wo, vec3 dir, vec3 n,Light lt){
    vec3 wi = -1.0*vec3(dir);
     vec3 h = normalize(wi+wo);
     float nv = abs(dot(n,wo))+1e-5;
     float nl = clamp(dot(n,wi),0.0,1.0);
     //float vh = clamp(dot(h,wo),0.0,1.0);
     float lh = clamp(dot(h,wi),0.0,1.0);
     float nh =clamp(dot(h,n),0.0,1.0);
     float roughFix = rough*rough;
    vec3 F = fresnelReflect(F0,lh);
    float D = distributionGGX(nh,roughFix);
    float G = geometryGGX(nv,nl,roughFix);
    vec3 kd = vec3(1.0) - F;
     kd *=1.0 - metal; 
     vec3 Fr = (D*G)*F;
     vec3 Fd = kd/PI;
    lcolor += Fd*nl*lt.diffuse;
    spec += D*G*F*nl*lt.diffuse;
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
`,_.isNone(e.roughMap)||(i+=`
    uniform sampler2D roughMap;
`),_.isNone(e.metalMap)||(i+=`
    uniform sampler2D metalMap;
`),e.IBL&&(i+=`
uniform mat4 viewMatrix;
uniform float MAX_MIPCOUNT;
#extension GL_EXT_shader_texture_lod : enable
#extension GL_OES_standard_derivatives : enable
`+`
vec3 fresnelSchlickRoughness(vec3 f0,float cosTheta, float rfs)
{
    return f0 + (max(vec3(1.0 - rfs), f0) - f0) * pow(1.0 - cosTheta, 5.0);
}   
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}

vec3 getIBLIradianceColor(const samplerCube iradMap, float mip,vec3 kS,vec3 wN){
    #ifdef DF_TEX_LOD
    vec3 iblDiffuse = textureCube(iradMap,wN,mip).rgb;
    #else
    vec3 iblDiffuse = textureCube(iradMap,wN,mip).rgb;
    #endif
   
    vec3 kD = 1.0 - kS;
    kD *=1.0 - metal; 
    return kD * iblDiffuse;
}
#ifdef DF_RADSPMAP
const vec2 invAtan = vec2(0.1591,0.3183);
vec4 sampleSPMap(const sampler2D spMap,vec3 dir,float mip){
    vec2 uv = vec2(atan(dir.z,dir.x),asin(dir.y));
    uv *= invAtan;
    uv += 0.5;
    #ifdef DF_TEX_LOD
    return texture2DLodEXT(spMap,uv,mip);
    #else
    return texture2D(spMap,uv,mip);
    #endif

    
}
vec4 sampleSPMap2(const sampler2D spMap,vec3 dir,float mip){
    vec2 uv = vec2(atan(dir.z,dir.x),asin(dir.y));
    uv *= invAtan;
    uv += 0.5; 
    return texture2D(spMap,uv,mip);

    
}
vec3 getIBLIradianceColorBySP(const sampler2D iradMap, float mip,vec3 kS,vec3 wN){

    vec3 iblDiffuse = sampleSPMap(iradMap,wN,mip).rgb;
    vec3 kD = 1.0 - kS;
    kD *=1.0 - metal; 
    return kD * iblDiffuse;
}
#endif

`+`

float getSpecularMIPLevel( const in float roughness, float maxMIPLevelScalar ) {
    float sigma = PI * roughness * roughness / ( 1.0 + roughness );
    float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
    return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
}
vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}

float getSpecRough(vec3 normal,float rf){
    #ifdef DF_DERIVATIVES
    vec3 dxy = max( abs( dFdx( normal ) ), abs( dFdy( normal ) ) );
    float geometryRoughness = max(max( dxy.x, dxy.y ), dxy.z );
    #else
    float geometryRoughness =0.0;
    #endif
    float specRough = max(rf, 0.0525 );
    specRough += geometryRoughness;
    specRough = min( specRough, 1.0 );
    return specRough;
}
#ifdef DF_RADSPMAP
vec3 getIBLSpecColorBySP(const sampler2D radMap, float specRough, vec3 R, float nv, vec3 kS,vec2 dfg){
    
    #ifdef DF_LINEARMIP
        float specMip = specRough*MAX_MIPCOUNT;
    #else
        float specMip = getSpecularMIPLevel(specRough,MAX_MIPCOUNT-1.0);
    #endif
  
    vec3 iblSpecular =  sampleSPMap(radMap,R,specMip).rgb;
   
    
    return (kS*dfg.x+dfg.y)*iblSpecular;
}
#endif
vec3 getIBLSpecColor(const samplerCube radMap, float specRough, vec3 R, float nv, vec3 kS,vec2 dfg){
    //float mipF = fract(specMip);
    //float mipInt = floor(specMip);
    //vec3 color0 = textureCube(radMap,R,mipInt).rgb;
    //vec3 color1 = textureCube(radMap,R,mipInt+1.0).rgb;
    //vec3 iblSpecular = mix(color0,color1,mipF);
    //vec2 dfg = texture2D(lutMap,vec2(nv,rough)).xy;
    #ifdef DF_LINEARMIP
        float specMip = specRough*MAX_MIPCOUNT;
    #else
        float specMip = getSpecularMIPLevel(specRough,MAX_MIPCOUNT-1.0);
    #endif
    #ifdef DF_TEX_LOD
        vec3 iblSpecular =  textureCubeLodEXT(radMap,R,specMip).rgb;
    #else
        vec3 iblSpecular =  textureCube(radMap,R,specMip).rgb;
    #endif
    return (kS*dfg.x+dfg.y)*iblSpecular;
}
`),_.isNone(e.irradianceMap)||(i+=`
uniform samplerCube irradianceMap;
`),_.isNone(e.radianceMap)||(i+=`
#ifdef DF_RADSPMAP
uniform sampler2D radianceMap;
#else
uniform samplerCube radianceMap;
#endif
#ifdef DF_LUTMAP
uniform sampler2D  lutMap;
#endif
`)):_.isNone(e.specular)?(i+=`
struct Light{
    vec3 diffuse;
};`,i+=`
void calLight(inout vec3 lcolor, inout vec3 spec, vec3 eyeDir, vec3 direction, vec3 normal,Light lt){
    lcolor  =lcolor + lt.diffuse*max(dot(normal,-1.0*direction),0.0);
}
`):(i+=`    
struct Light{
  vec3 diffuse;
  vec3 specular;
  float shininess;
};`,i+=`
void calLight(inout vec3 lcolor, inout vec3 spec,vec3 eyeDir, vec3 direction,vec3 normal, Light lt){
    lcolor  =lcolor + lt.diffuse*max(dot(normal,-1.0*direction),0.0);
    vec3 refDir = reflect(direction,normal);
    spec = spec + pow(max(dot(eyeDir,refDir),0.0),lt.shininess)*lt.specular;
}`),_.isNone(e.dirLightCount)||0<(t=e.dirLightCount)&&(i+=de.getDefineStr("dirLightCount",t),i+=`
struct dLight{
    vec3 direction;
    Light light;
};
uniform dLight dirL[dirLightCount+1];
`,i+=`
void calDirLights(inout vec3 lcolor,inout vec3 spec,vec3 eyeDir,vec3 normal){
  for (int i =0;i<dirLightCount;i++){
      calLight(lcolor,spec,eyeDir,dirL[i].direction,normal,dirL[i].light);
  }
}`),_.isNone(e.pointLightCount)||0<(r=e.pointLightCount)&&(i+=de.getDefineStr("pointLightCount",r),i+=` 
struct pointLight{
Light light;
vec3 position;
vec3 params;  //constant,linear,quadratic;
};
uniform pointLight pointL[pointLightCount+1];
`,i+=`
void calPointLights(inout vec3 lcolor,inout vec3 spec, vec3 eyeDir,vec3 normal){
    for(int i=0; i<pointLightCount; i++){
      float distance = length(pointL[i].position +eyeDir);
      float intst = pointL[i].params.x + distance*pointL[i].params.y + distance*distance*pointL[i].params.z;
      vec3 direction  = normalize(viewPos.xyz-pointL[i].position);
      calLight(lcolor,spec,eyeDir,direction,normal,pointL[i].light);
      float decay = 1.0/intst;
      lcolor = decay*lcolor;
      spec = decay*spec;
    }
}`)),e.receiveShadow&&(i+=r=de.getDefineStr("lightShadowCount",e.lightShadowCount),a+=r,a+=`
    uniform mat4 lightPVM[lightShadowCount];
    varying vec4 lightSpacePos[lightShadowCount];
`,i+=`
uniform vec2 biasStep[lightShadowCount];
precision mediump float;
uniform sampler2D depthMap[lightShadowCount];
varying vec4 lightSpacePos[lightShadowCount];
float calShadow(vec4 pos, vec2 bias_step, sampler2D depth_map){
    float shadow = 0.0;
    vec3 projSd = pos.xyz/pos.w;
    projSd = projSd*0.5 +0.5;

   
    for(int i = -1; i<=1;i++){
        for(int j=-1; j<=1; j++){
            vec2 uv = projSd.xy+vec2(i,j)*bias_step.y;
            if(projSd.z-bias_step.x>texture2D(depth_map,uv).r){
                shadow += 0.8;
            } 
        }
    }
    if (projSd.z>1.0 || projSd.z<0.00)
        shadow = 0.0;

    
    
    return shadow/9.0;
}

float calAllShadow(){
    float shadow = 0.0;
    for(int jr=0; jr<lightShadowCount; jr++){
        shadow += calShadow(lightSpacePos[jr],biasStep[jr],depthMap[jr]);
    }
    return shadow/float(lightShadowCount);
  }
`),e.enableFog&&(_.isNone(e.fogExp)?i+=`
uniform vec2 fogLinear;
uniform vec3 fogColor;
`:i+=`
uniform float density;
uniform vec3 fogColor;
`),_.isNone(e.fhead_add)||(i+=e.fhead_add),_.isNone(e.vhead_add)||(a+=e.vhead_add),[a,i]}static createShaderBody(e){var t=ne;t+=`
    vec4 inPos = vec4(vertexPos);
`;var r=ne;return e.useUV&&(t+=`
  vUV = uv;
`,r+=`
    vec2 fUV = vUV;
`),_.isNone(e.uvTran)||(r+=`
fUV.x = fUV.x*uvTran.x+uvTran.y;
fUV.y = fUV.y*uvTran.z+uvTran.w;
`),_.isNone(e.heightMap)||(t+=`
 
  //mat3 tan = mat3(vertexTangent,cross(vertexNormal,vertexTangent),vertexNormal);
  //tan = transposeDiv(tan);
  float height = texture2D(heightMap,vUV).r*2.0-1.0;
  inPos.xyz += vertexNormal*height*0.02; 
  //vec3 tanCamPos = tan*(modelViewInv*vec4(0.0,0.0,0.0,1.0)).xyz;
  //vec3 tanfragPos = tan*inPos.xyz;
  //tanViewDir = tanCamPos -tanfragPos;
`,r+=`
float eps = 0.0000001;
vec3 viewDirT = normalize(tanViewDir);

//fUV+=vec2(viewDirT.x/(viewDirT.z+eps),viewDirT.y/(viewDirT.z+eps))*height*0.005;
`),_.isNone(e.normalMap)?_.isNone(e.modelNormalMap)?t+=`
    vNormal = normalize((normalMatrix*vec4(vertexNormal,1.0)).xyz);
`:r+=`
    vec4 texn = vec4(texture2D(modelNormalMap,fUV).rgb*2.0-1.0,1.0);
    vec3 vNormal = normalize((normalMatrix*texn).xyz);
`:(t+=`
    vec3 BiTan = cross(vertexNormal,vertexTangent);
    TBN = mat3(vertexTangent,BiTan,vertexNormal);
`,r+=`
    vec3 texn = texture2D(normalMap,fUV).rgb*2.0-1.0;
    vec3 vNormal = normalize((normalMatrix*vec4(TBN*texn,1.0)).xyz);
`),_.isNone(e.texture0)?_.isNone(e.cubeMap)?_.isNone(e.rectSphereMap)?_.isNone(e.matColor)?_.isNone(e.vertexColor)?r+=`
        gl_FragColor = vec4(0.3,0.4,0.5,1.0);
  `:(t+=`
    vColor = vertexColor;
`,r+=`
    gl_FragColor = vColor;
`):r+=`
    gl_FragColor = matColor;
`:(t+=he,r+=`
    vec2 ruv = samplerSphericalMap(normalize(skyPos));
    gl_FragColor = texture2D(rectSphereMap,ruv);
`):(t+=he,r+=`
    gl_FragColor = textureCube(cubeMap,normalize(skyPos.xyz));
`):r+=`
    vec4 color_tex0 = texture2D(texture0,fUV);
    gl_FragColor =  color_tex0;
`,_.isNone(e.texture1)||(r+=`
    vec4 color_tex1 = texture2D(texture1,fUV);
`),e.vgsBlur&&(r+=`
vec4 weight = vec4(0.1945946, 0.1216216, 0.054054, 0.016216);
float step = 3.0/1000.0;

vec3 result = texture2D(texture0,fUV).rgb*0.227027;
for(int i =1; i<5;i++){
    result +=texture2D(texture0,fUV + vec2(0,i)*step).rgb*weight[i-1];
    result +=texture2D(texture0,fUV + vec2(0,-i)*step).rgb*weight[i-1];
}
gl_FragColor.rgb = result;
`),e.hgsBlur&&(r+=`
vec4 weight = vec4(0.1945946, 0.1216216, 0.054054, 0.016216);
float step = 3.0/1000.0;
vec3 result = texture2D(texture0,fUV).rgb*0.227027;
for(int i =1; i<5;i++){
    result +=texture2D(texture0,fUV + vec2(i,0)*step).rgb*weight[i-1];
    result +=texture2D(texture0,fUV + vec2(-i,0)*step).rgb*weight[i-1];
}
gl_FragColor.rgb = result;
`),e.lightBlur&&(r+=`
    float step = 6.0/1000.0;
    vec3 result = vec3(0.0);
    for(int i =-2; i<=2;i++){
        for(int j=-2; j<=2;j++){
            result +=texture2D(texture_brighter,fUV + vec2(i,j)*step).rgb;
        }
    }
    gl_FragColor.rgb = result/25.0+gl_FragColor.rgb;
`),e.texBlend===ie.Add&&(r+=`
    gl_FragColor.rgb = gl_FragColor.rgb +color_tex1.rgb;  
`),e.calRadiance&&(r+=`
vec3 irradiance = vec3(0.0);
	vec3 nm = normalize(skyPos.xyz);
	calIrradiance(irradiance,nm);
	gl_FragColor.rgb = irradiance;
`),e.calBrdf&&(r+=`
vec2 integratedBRDF = IntegrateBRDF(fUV.x, fUV.y);
gl_FragColor.rg = integratedBRDF;
gl_FragColor.b = 0.0;
`),e.calIBLSpec&&(r+=`
vec3 N = normalize(skyPos.xyz);
    
    // make the simplyfying assumption that V equals R equals the normal 
    vec3 R = N;
    vec3 V = R;
    vec3 prefilteredColor = vec3(0.0);
    float totalWeight = 0.0;
    const int SAMPLE_COUNT = 1024;
    for(int i = 0; i < SAMPLE_COUNT; ++i)
    {
        // generates a sample vector that's biased towards the preferred alignment direction (importance sampling).
        vec2 Xi = Hammersley(i, SAMPLE_COUNT);
        vec3 H = ImportanceSampleGGX(Xi, N, roughness);
        vec3 L  = normalize(2.0 * dot(V, H) * H - V);

        float NdotL = max(dot(N, L), 0.0);
        if(NdotL > 0.0)
        {
            // sample from the environment's mip level based on roughness/pdf
            float NdotH = max(dot(N, H), 0.0);
            float HdotV = max(dot(H, V), 0.0);
            float D   = distributionGGX(NdotH, roughness);
            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001; 

            float resolution = 512.0; // resolution of source cubemap (per face)
            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);
            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);

            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); 
            
            prefilteredColor += textureCube(cubeMap, L, mipLevel).rgb * NdotL;
            totalWeight      += NdotL;
        }
    }

    prefilteredColor = prefilteredColor / totalWeight;
    gl_FragColor = vec4(prefilteredColor.rgb, 1.0);
`),_.isNone(e.diffuse)?(t+=`
         gl_Position = projectionMatrix * modelViewMatrix * vec4(inPos.xyz,1.0);
    `,e.receiveShadow&&(t+=ce,r+=`
float shadow = calAllShadow();
gl_FragColor.rgb = (1.0-shadow)*gl_FragColor.rgb;

`)):(t+=`
    viewPos = modelViewMatrix * vec4(inPos.xyz,1.0);
    gl_Position = projectionMatrix * viewPos;
   
`,r+=`
    vec3 lcolor = vec3(0.0);
    vec3 lspec = vec3(0.0);
    vec3 ambient = vec3(0.0);
    vec3 eyeDir = normalize(-1.0*viewPos.xyz);
    `,e.PBR&&(_.isNone(e.roughMap)||(r+=`
    rough *= min(texture2D(roughMap,fUV).x,1.0);
`),r+=`
    rough *= roughness;
    rough = clamp(rough,0.0,1.0);
    metal = clamp(metal,0.0,1.0);
`,_.isNone(e.metalMap)||(r+=`
   
    metal *= texture2D(metalMap,fUV).x;
`),r+=`
    metal *= metalness;
`,_.isNone(e.aoMap)||(r+=`
ao = texture2D(aoMap,fUV).r;

`),r+=`

gl_FragColor.r= pow(gl_FragColor.r, 2.2);
gl_FragColor.g= pow(gl_FragColor.g, 2.2);
gl_FragColor.b= pow(gl_FragColor.b, 2.2);
    F0 = mix(F0,gl_FragColor.rgb,metal);
    //gl_FragColor = LinearTosRGB(gl_FragColor);

    
`,e.IBL&&(r+=`
vec3 wN = inverseTransformDirection(vNormal,viewMatrix);
float nv = clamp(dot(vNormal, eyeDir),0.0,1.0);
vec3 kS = fresnelSchlickRoughness(F0,nv,rough);
#ifdef DF_IRRADIANCEMAP
vec3 iradColor = getIBLIradianceColor(irradianceMap,0.0,kS,wN);
#else
#ifdef DF_RADSPMAP
vec3 iradColor = getIBLIradianceColorBySP(radianceMap,MAX_MIPCOUNT+1.0,kS,wN);
#else
vec3 iradColor = getIBLIradianceColor(radianceMap,MAX_MIPCOUNT+1.0,kS,wN);
#endif
#endif

ambient += iradColor*gl_FragColor.rgb*ao;
`),_.isNone(e.irradianceMap)||(r+=`


`),_.isNone(e.radianceMap)||(r+=`
vec3 R = reflect(-1.0*eyeDir, vNormal);
R =  inverseTransformDirection(R,viewMatrix);
#ifdef DF_LINEARMIP
    float specRough =rough;
#else
    float specRough = getSpecRough(vNormal,rough);
#endif

#ifdef DF_LUTMAP
    vec2 dfg = texture2D(lutMap,vec2(nv,rough)).xy;
#else
    vec2 dfg = integrateSpecularBRDF(nv,rough);
#endif
#ifdef DF_RADSPMAP
vec3 iblSpecular  = getIBLSpecColorBySP(radianceMap,specRough,R,nv,kS,dfg);
#else
vec3 iblSpecular  = getIBLSpecColor(radianceMap,specRough,R,nv,kS,dfg);
#endif
float spAo = computeSpecularOcclusion(nv,ao,specRough);
iblSpecular *= spAo;
ambient +=iblSpecular;
`)),_.isNone(e.dirLightCount)||0<e.dirLightCount&&(r+=`
    calDirLights(lcolor,lspec,eyeDir,vNormal);
`),_.isNone(e.pointLightCount)||e.pointLightCount&&(r+=`
    calPointLights(lcolor,lspec,eyeDir,vNormal);
`),e.receiveShadow&&(t+=ce,r+=`
float shadow = calAllShadow();
lcolor = (1.0-shadow)*lcolor;
lspec = (1.0-shadow)*lspec;
`),r+=`
ambient +=ambientLight*gl_FragColor.rgb;
gl_FragColor.rgb = gl_FragColor.rgb*lcolor+ambient;
`,_.isNone(e.envMap)||(r+=`
  vec3 envColor = vec3(0.0);
  float ratio = 0.0;
`,_.isNone(e.normalMap)?(_.isNone(e.reflective)||(t+=`
    skyPos = reflect(normalize(viewPos.xyz),normalize(vNormal));
    skyPos = inverseTransformDirection(skyPos,viewMatrix);
  `,r+=`
ratio += reflective;
 envColor += reflective*textureCube(cubeMap,skyPos).xyz;
`),_.isNone(e.refractParams)||(t+=`
    refractR.a = refractParams[0];
    refractR.rgb = refract(normalize(viewPos.xyz),normalize(vNormal),1.0/refractParams[1]);
    refractR.rgb = inverseTransformDirection(refractR.rgb,viewMatrix);
`,r+=`
    ratio += refractR.a;
    envColor += refractR.a*textureCube(cubeMap,refractR.xyz).xyz;
`)):(_.isNone(e.reflective)||(r+=`
vec3 skyPos = reflect(normalize(viewPos.xyz),normalize(vNormal));
skyPos = inverseTransformDirection(skyPos,viewMatrix);
ratio += reflective;
 envColor += reflective*textureCube(cubeMap,skyPos).xyz;
`),_.isNone(e.refractParams)||(r+=`
refractR.a = refractParams[0];
refractR.rgb = refract(normalize(viewPos.xyz),normalize(vNormal),1.0/refractParams[1]);
refractR.rgb = inverseTransformDirection(refractR.rgb,viewMatrix);
ratio += refractR.a;
 envColor += refractR.a*textureCube(cubeMap,refractR.xyz).xyz;
`)),e.PBR&&(r+=`
    //ratio =0.02;
`),r+=`
  gl_FragColor.rgb = mix(gl_FragColor.rgb,envColor,ratio);
`),r+=`
    gl_FragColor.rgb = gl_FragColor.rgb+lspec;

`),e.enableFog&&(_.isNone(e.fogExp)?r+=`
float start = fogLinear[0];
float end = fogLinear[1];
float z = gl_FragCoord.z/gl_FragCoord.w;
float fogFactor = (z-start)/(end-start);
fogFactor = clamp(fogFactor,0.0,1.0);
gl_FragColor.rgb = mix(gl_FragColor.rgb,fogColor,fogFactor);
`:r+=`
const float LOG2 = 1.44265;
float z = gl_FragCoord.z/gl_FragCoord.w;
float fogFactor = exp2(-density*density*z*z*LOG2);
fogFactor = clamp(fogFactor,0.0,1.0);
gl_FragColor.rgb = mix(fogColor,gl_FragColor.rgb,fogFactor);
`),_.isNone(e.hdrExposure)||(r+=`
    gl_FragColor.rgb = toneMapping(gl_FragColor.rgb);
  
`),e.gammaCorrect&&(r+=`
//gl_FragColor.rgb = gl_FragColor.rgb/(vec3(1.0)+gl_FragColor.rgb);
    gl_FragColor.rgb = pow(gl_FragColor.rgb,vec3(0.4545));
  //  gl_FragColor.a = 1.0;
`),_.isNone(e.fbody_add)||(r+=e.fbody_add),_.isNone(e.vbody_add)||(t+=e.vbody_add),[t+="}",r+="}"]}static createFromShaderOption(e,t){var r=new W;r.shaderOption=e;var a,i,o,s,n,l,h,c,u,d,f,p,m,v="";if(_.isNone(e.texture0)?_.isNone(e.matColor)||r.setUniform("matColor",w.Vec4,e.matColor):(a=de.createTextureFromOps(e.texture0),r.setUniform("texture0",w.texture,a),r.addTexture(a),e.useUV=!0),_.isNone(e.calIBLSpec)||r.setUniform("roughness",w.float,e.roughness),_.isNone(e.calBrdf)||(e.useUV=!0),_.isNone(e.hdrExposure)||r.setUniform("hdrExposure",w.float,e.hdrExposure),_.isNone(e.normalMap)?_.isNone(e.modelNormalMap)||(a=e.modelNormalMap,a=new Texture(a),r.setUniform("modelNormalMap",w.texture,a),r.addTexture(a),e.useUV=!0):(i=de.createTextureFromOps(e.normalMap),r.setUniform("normalMap",w.texture,i),r.addTexture(i),e.useUV=!0),_.isNone(e.cubeMap)&&_.isNone(e.envMap)||(i=e.cubeMap||e.envMap,i=de.createTextureFromOps(i,TextureType.cube),r.setUniform("cubeMap",w.texture,i),r.addTexture(i)),_.isNone(e.rectSphereMap)||(o=e.rectSphereMap,o=de.createTextureFromOps(o),r.setUniform("rectSphereMap",w.texture,o),r.addTexture(o),e.useUV=!0),_.isNone(e.reflective)||r.setUniform("reflective",w.float,e.reflective),_.isNone(e.refractParams)||r.setUniform("refractParams",w.Vec2,e.refractParams),_.isNone(e.texture1)||(n=null,n=e.texture1 instanceof Texture?e.texture1:(o=e.texture1,new Texture(o)),e.useUV=!0,r.setUniform("texture1",w.texture,n),r.addTexture(n)),_.isNone(r.shaderOption.texture_brighter)||(l=null,l=e.texture_brighter instanceof Texture?e.texture_brighter:(s=e.texture_brighter,new Texture(s)),r.setUniform("texture_brighter",w.texture,l),r.addTexture(l),e.useUV=!0),r.shaderOption.receiveShadow){for(var g=0,x=0;x<t.dirLights.length;x++){var y=t.dirLights[x];y.castShadow&&(r.setLightShadowParams(y,g),g+=1)}for(var M=0;M<t.pointLights.length;M++){var T=t.pointLights[M];T.castShadow&&(r.setLightShadowParams(T,g),g+=1)}r.shaderOption.lightShadowCount=g=0===g?1:g}e.enableFog&&(_.isNone(e.fogExp)?(n=20,l=[s=1,1,1],_.isNone(e.fogLinear)||(s=e.fogLinear.start,n=e.fogLinear.end,l=e.fogLinear.fogColor),r.setUniform("fogLinear",w.Vec2,[s,n]),r.setUniform("fogColor",w.Vec3,l)):(void 0===(h=e.fogExp).density&&(h.density=.09),void 0===h.fogColor&&(h.fogColor=[1,1,1]),r.setUniform("density",w.float,h.density),r.setUniform("fogColor",w.Vec3,h.fogColor))),_.isNone(e.aoMap)||(c=null,c=e.aoMap instanceof Texture?e.aoMap:(h=e.aoMap,new Texture(h)),r.setUniform("aoMap",w.texture,c),r.addTexture(c),e.useUV=!0),e.PBR&&(_.isNone(e.roughMap)||(u=null,u=e.roughMap instanceof Texture?e.roughMap:(c=e.roughMap,new Texture(c)),r.setUniform("roughMap",w.texture,u),r.addTexture(u),e.useUV=!0),u=1,_.isNone(e.roughness)||(u=e.roughness),r.setUniform("roughness",w.float,u),_.isNone(e.metalMap)||(d=null,d=e.metalMap instanceof Texture?e.metalMap:(u=e.metalMap,new Texture(u)),r.setUniform("metalMap",w.texture,d),r.addTexture(d),e.useUV=!0),d=1,_.isNone(e.metalness)||(d=e.metalness),r.setUniform("metalness",w.float,d),_.isNone(e.irradianceMap)||(d=de.createTextureFromOps(e.irradianceMap,TextureType.cube),r.setUniform("irradianceMap",w.texture,d),r.addTexture(d),e.IBL=!0,v+="#define DF_IRRADIANCEMAP\n"),e.linearMip&&(v+="#define DF_LINEARMIP\n"),_.isNone(e.radianceMap)||((f=de.createTextureFromOps(e.radianceMap)).type===TextureType.default&&(v+="#define DF_RADSPMAP\n"),r.setUniform("radianceMap",w.texture,f),r.addTexture(f),f.state===LoadState.loaded?(p=f.getMipCount(),r.setUniform("MAX_MIPCOUNT",w.float,p)):f.onLoadedCalls.push(function(e){var t=f.getMipCount();r.setUniform("MAX_MIPCOUNT",w.float,t)}),_.isNone(e.lutMap)||(m=de.createTextureFromOps(e.lutMap),r.setUniform("lutMap",w.texture,m),r.addTexture(m),v+="#define DF_LUTMAP\n"),v+="#define DF_RADIANCEMAP\n",e.useUV=!0,e.IBL=!0,p=t.gl.getExtension("EXT_shader_texture_lod"),m=t.gl.getExtension("OES_standard_derivatives"),_.isNone(p)||(v+="#define DF_TEX_LOD\n"),_.isNone(m)||(v+="#define DF_DERIVATIVES\n"))),_.isNone(e.heightMap)||(e.uniformsToUp.modelViewInv=!0,L=null,L=e.heightMap instanceof Texture?e.heightMap:(m=e.heightMap,new Texture(m)),r.setUniform("heightMap",w.texture,L),r.addTexture(L),e.useUV=!0),_.isNone(e.uvTran)||r.setUniform("uvTran",w.Vec4,e.uvTran);var L=de.createShaderHead(e),e=de.createShaderBody(e);return r.vsource=L[0]+e[0],r.fsource=de.filterShader(v+L[1]+e[1]),r}static createTextureFromOps(e,t,r){var a=null;return e instanceof Texture?a=e:(t=e instanceof Array?TextureType.cube:TextureType.default,(a=new Texture(e)).type=t),TextureType.cube,a}static filterShader(e){var t=e;return t=-1!==e.indexOf("gl_FragData")?e.replace(new RegExp("gl_FragColor","g"),"gl_FragData[0]"):t}static updateDirLightInfo(e,t,r,a){for(var i in r){var o="dirL["+i+"]",s=r[i],n=s.transform.pos,n=_.normalize(n),i=_.multiplyV3(s.color,a.shaderOption.diffuse);a.setUniform(o+".light.diffuse",w.Vec3,[i.x,i.y,i.z]);n=new l(-1*n.x,-1*n.y,-1*n.z,0),n=_.vec4MultiMatrix(n,t);a.setUniform(o+".direction",w.Vec3,[n.x,n.y,n.z]),a.shaderOption.PBR||_.isNone(a.shaderOption.specular)||_.isNone(s.specular)||(s=_.multiplyV3(s.specular,a.shaderOption.specular),a.setUniform(o+".light.specular",w.Vec3,[s.x,s.y,s.z]),a.setUniform(o+".light.shininess",w.float,a.shaderOption.shininess))}}static updatePointLightInfo(e,t,r,a){for(var i in r){var o="pointL["+i+"]",s=r[i],i=s.transform.pos,i=new l(i.x,i.y,i.z,1),i=_.vec4MultiMatrix(i,t);a.setUniform(o+".position",w.Vec3,[i.x,i.y,i.z]),a.setUniform(o+".params",w.Vec3,[s.constant,s.linear,s.quadratic]);i=_.multiplyV3(s.color,a.shaderOption.diffuse);a.setUniform(o+".light.diffuse",w.Vec3,[i.x,i.y,i.z]),a.shaderOption.PBR||_.isNone(a.shaderOption.specular)||_.isNone(s.specular)||(s=_.multiplyV3(s.specular,a.shaderOption.specular),a.setUniform(o+".light.specular",w.Vec3,[s.x,s.y,s.z]),a.setUniform(o+".light.shininess",w.float,a.shaderOption.shininess))}}static __updateSingleShadow(e,t,r,a,i){var o,s;a.castShadow&&t.shaderOption.receiveShadow&&(o="lightPVM["+i+"]",i=(s=a.shadowCam).getProjectionMatrix(),s.transform.setPosition(a.transform.pos.x,a.transform.pos.y,a.transform.pos.z),s.transform.lookAt(0,0,0),s=s.getViewMatrix(),r=r.getDerivTranMatrix(),r=_.multiplyMat(i,_.multiplyMat(s,r)),r=_.mat2Arr(r),t.setUniform(o,w.Mat4,r))}static updateShadowInfo(e,t,r,a){if(t.shaderOption.receiveShadow){for(var i=0,o=0;o<a.dirLights.length;o++){var s=a.dirLights[o];s.castShadow&&(de.__updateSingleShadow(e,t,r,s,i),i+=1)}for(var n=0;n<a.pointLights.length;n++){var l=a.pointLights[n];l.castShadow&&(de.__updateSingleShadow(e,t,r,l,i),i+=1)}}}static updateLightMatInfo(e,t,r,a,i){var o;_.isNone(r)||(de.updateShadowInfo(e,r,a,i),_.isNone(r.shaderOption.diffuse)||(o=t.getViewMatrix(),de.updateDirLightInfo(e,o,i.dirLights,r),de.updatePointLightInfo(e,o,i.pointLights,r),r.setUniform("ambientLight",w.Vec3,[i.ambientLight.x,i.ambientLight.y,i.ambientLight.z]),a=a.getDerivInvTranMatrix(),t=t.transform.getDerivTranMatrix(),t=_.getNormalMatrixArr(a,t),r.setUniform("normalMatrix",w.Mat4,t)))}}var fe=1;class pe{constructor(){this.cameraList=[],this._dirty=!0,this._activeDraw=!1,this.entityList=[],this.clearColor=[.3,.2,.2,1],this.gl=null,this.ambientLight=new P(0,0,0),this.dirLights=[],this.pointLights=[],this.onBeforeDrawFrame=[],this.onAfterDrawFrame=[],this._befDrawRunQueue=[],this._aftDrawRunQueue=[]}registerFrameCalls(e,t){"function"!=typeof e&&console.error("wrong parameters: not a function,",e),(t===fe?this.onAfterDrawFrame:this.onBeforeDrawFrame).push(e)}postFrameRunnable(e,t){"function"!=typeof e&&console.error("wrong parameters: not a function,",e),(t===fe?this._aftDrawRunQueue:this._befDrawRunQueue).push(e)}update(e){this._dirty}requireUpdate(){this._dirty=!0}initRenderState(e,t,r,a,i){e.clearColor(t,r,a,i),e.clearDepth(1),e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)}sortCameras(){return _.bucketSortDict(this.cameraList,function(e){return e.depth},100,0)}sortEntities(){return _.bucketSortDict(this.entityList,function(e){return e.renderLayer},100,0)}addCamera(e){this.cameraList.push(e)}addEntity(e){e instanceof M&&(null===this.entityList&&(this.entityList=[]),this.entityList.push(e))}clearCamera(e,t){return t.clearMask===T.default?this.initRenderState(e,t.clearColor[0],t.clearColor[1],t.clearColor[2],t.clearColor[3]):t.clearMask===T.onlyDepth&&(e.clearDepth(1),e.clear(e.DEPTH_BUFFER_BIT)),!0}bindCamera(e,t){var r=!0;return null!==t.renderTarget?(t.renderTarget.state===LoadState.init&&t.renderTarget.loadTexture(e,null),t.renderTarget.state!==LoadState.init?t.renderTarget instanceof RenderTexture&&(e.bindFramebuffer(e.FRAMEBUFFER,t.renderTarget.frameBufferId),t.renderTarget.hasColorBuffer?e.bindRenderbuffer(e.RENDERBUFFER,t.renderTarget.depthRBuffer):(e.enable(e.CULL_FACE),e.cullFace(e.BACK)),t.renderTarget.updateFBODate(e,t)):r=!1):(e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null)),r}unbindCamera(e,t){}drawRenderLayer(r,a,e){for(var i=this,t=0;t<e.length;t++){var o=e[t];o.material.getActive(a,function(e,t){a.id!==t.id&&(i.unbindCamera(r,a),i.bindCamera(r,t),i.clearCamera(r,t)),de.updateLightMatInfo(r,t,e,o.transform,i),pe.drawEntity(r,t,o,e),a.id!==t.id&&(i.unbindCamera(r,t),i.bindCamera(r,a))})}}drawCamera(e,t,r){if(null!==t.beforeDrawFunc&&t.beforeDrawFunc(r),this.bindCamera(e,t),this.clearCamera(e,t),t.renderMask===v.everything)for(var a in r){a=r[a];this.drawRenderLayer(e,t,a)}else if(t.renderMask===v.layers)for(var i in t.renderLayers){i=r[t.renderLayers[i]];_.isNone(i)||this.drawRenderLayer(e,t,i)}this.unbindCamera(e,t),null!==t.afterDrawFunc&&t.afterDrawFunc(e,r)}drawOneFrame(e){if(null!==e){this.update(e);var t,r=this.sortCameras(),a=this.sortEntities();for(t in r)for(var i=r[t],o=0;o<i.length;o++){var s=i[o];if(s.enable)if(_.isNone(s.renderTarget)||s.renderTarget.type!==TextureType.cube)this.drawCamera(e,s,a);else if(s.drawMips)for(var n=0;n<s.renderTarget.getMipCount();n++){s.renderTarget.currentMip=n;for(var l=0;l<6;l++)this.drawCamera(e,s,a)}else for(var h=0;h<6;h++)this.drawCamera(e,s,a)}}else console.error("couldn't draw WebglRenderingContext is null")}enableActiveDraw(e){this._activeDraw=e}draw(t){for(var e in void 0===t&&(t=this.gl),this.onBeforeDrawFrame)this.onBeforeDrawFrame[e]();for(;0<this._befDrawRunQueue.length;)this._befDrawRunQueue.shift()();for(var r in this._activeDraw?this._dirty&&(this.drawOneFrame(t),this._dirty=!1):this.drawOneFrame(t),this.onAfterDrawFrame)this.onAfterDrawFrame[r]();for(;0<this._aftDrawRunQueue.length;)this._aftDrawRunQueue.shift()();var a=this;window.requestAnimationFrame(function(e){a.draw(t)})}addLight(e){e instanceof z&&(_.isNone(this.dirLights)&&(this.dirLights=[]),this.dirLights.push(e)),e instanceof O&&(_.isNone(this.pointLights)&&(this.pointLights=[]),this.pointLights.push(e))}static drawEntity(e,t,r,a){var i,o,s,n,l;null!==r.mesh&&null!==a&&(i=t.getGLProj(),l=t.getViewMatrix(),r.transform.followCameraPos&&r.transform.setPosition(t.transform.pos.x,t.transform.pos.y,t.transform.pos.z),s=a.shaderOption.depthTest,o=a.shaderOption.depthWrite,s!==e.getParameter(e.DEPTH_TEST)&&(s?e.enable(e.DEPTH_TEST):e.disable(e.DEPTH_TEST)),o!==e.getParameter(e.DEPTH_WRITEMASK)&&(o?e.depthMask(!0):e.depthMask(!1)),(s=a.shaderOption.enableCull)!==e.getParameter(e.CULL_FACE)&&(s?e.enable(e.CULL_FACE):e.disable(e.CULL_FACE)),(o=e[a.shaderOption.cullFace])!==e.getParameter(e.CULL_FACE_MODE)&&e.cullFace(o),s=r.transform.getDerivTranMatrix(),o=h.getMVGLArr(l,s),a.setUniform(c.projectionMatrix,w.Mat4,i),a.setUniform(c.modelViewMatrix,w.Mat4,o),a.shaderOption.uniformsToUp.modelCameraPos&&(n=r.transform.getDerivInvTranMatrix(),s=t.transform.pos,n=_.vec3MultiMat4(s,n),a.setUniform("modelCameraPos",w.Vec3,[n.x,n.y,n.z])),a.shaderOption.uniformsToUp.modelViewInv&&(n=r.transform.getDerivInvTranMatrix(),t=t.transform.getDerivTranMatrix(),t=_.mat2Arr(math.multiply(n,t)),a.setUniform("modelViewInv",w.Mat4,t)),_.isNone(a.shaderOption.envMap)&&!a.shaderOption.IBL||(l=h.mat2Arr(l),a.setUniform("viewMatrix",w.Mat4,l)),r=r.mesh.getVertexBufferInfo(e),r=new x(e,i,o,a.getProgramInfo(e),r),y.drawRender(r))}calculateShadowLights(){for(var e=0,t=0;t<this.dirLights.length;t++)this.dirLights[t].castShadow&&(e+=1);for(var r=0;r<this.pointLights.length;r++)this.pointLights[r].castShadow&&(e+=1);return e}getPointLightsCount(){return this.pointLights.length}getDirectionalLightsCount(){return this.dirLights.length}}class me{static createSkyBox(e,t){void 0===(t=void 0===t?{}:t).skyBoxPath&&(t.skyBoxPath="../pics/cube/bridge/"),void 0===t.extension&&(t.extension=".jpg"),t.depthTest=!0,t.depthWrite=!0,t.receiveLight=!1,t.receiveShadow=!1,t.cullFace="FRONT";var r=B.createBox(90,90,90),a=t.skyBoxPath,i=t.extension;t.cubeMap=[a+"posx"+i,a+"negx"+i,a+"posy"+i,a+"negy"+i,a+"posz"+i,a+"negz"+i],t.matColor=null;e=me.createMaterial(e,t),t=new M("skybox");return t.mesh=r,t.material=e,t.transform.followCameraPos=!0,t}static createBloomMaterial(e,t){t=me.copyShaderOps(t.shaderOption);t.fhead_add=`
        #extension GL_EXT_draw_buffers : require 
        `,t.fbody_add=`
            float grey = gl_FragColor.r*0.299 + gl_FragColor.g*0.587 + gl_FragColor.b*0.114;
            if(grey>0.85){
                gl_FragData[1] = gl_FragColor;
            }else{
                gl_FragData[1] = vec4(0.0,0.0,0.0,1.0);
                
            }
            `;e=de.createFromShaderOption(t,e);return e.name="bloom_draw2Mat",e}static copyShaderOps(e){var t,r=new n;for(t in e)r[t]=e[t];return r}static createMaterial(e,t){void 0===t&&(t={});var r,a=new n;for(r in t)a[r]=t[r];a.matColor,void 0===a.receiveLight&&(a.receiveLight=!0),void 0===a.receiveShadow&&(a.receiveShadow=!1),a.receiveLight&&(void 0===a.diffuse&&(a.diffuse=new P(1,1,1)),void 0===a.specular&&(a.specular=new P(1,1,1)),void 0===a.shininess&&(a.shininess=10),i=o=0,_.isNone(e.dirLights)||(o=e.getDirectionalLightsCount()),_.isNone(e.pointLights)||(i=e.getPointLightsCount()),a.dirLightCount=o,a.pointLightCount=i,a.castShadow=!0);var i,o=de.createFromShaderOption(a,e);return t.receiveShadow&&(i=new n,(i=de.createFromShaderOption(i,e)).name="depthMaterial",o.addPassLayer(i,L.depth)),e.hdr_bloom&&(e=me.createBloomMaterial(e,o),o.addPassLayer(e,L.bloom_col2)),o}static createEntity(e,t,r){void 0===(r=void 0===r?{}:r).mesh&&(r.mesh=B.createSphere(1,20,20));var a=null,a=void 0!==r.material?r.material:this.createMaterial(e,r);void 0===t&&(t="entity_default");t=new M(t);return t.mesh=r.mesh,t.material=a,t}static createDefaultScene(e,t){void 0===(t=void 0===t?{}:t).hasLight&&(t.hasLight=!0),void 0===t.castShadow&&(t.castShadow=!0),void 0===t.hasSkyBox&&(t.hasSkyBox=!1);var r=S.initCanvas(e,t.canvasLayout),a=r.canvas.width,i=r.canvas.height;console.log("SceneUtil w==",a,"h==",i),r.viewport(0,0,a,i);var o=new pe;o.gl=r;var s=b.createDefaultCamera(a/i);s.name="main_camera",o.addCamera(s);e=null;t.hasLight&&(r=null,r=void 0===t.lightPos?new P(5,5,5):t.lightPos,n=!0,void 0!==t.isPoint&&(n=t.isPoint),e=G.createShadowLight(a,i,r,t.castShadow,n),o.addLight(e),t.castShadow&&o.addCamera(e.shadowCam),o.ambientLight=new P(.3,.3,.3));var n=null;return t.hasSkyBox&&(n=me.createSkyBox(o,{skyBoxPath:t.skyBoxPath}),o.addEntity(n)),{scene:o,camera:s,skybox:n,dirLight:e,ambientLight:o.ambientLight}}}class ve{static createCubeCamera(e,t,r,a){void 0===a&&(a=TextureType.cube);a=new RenderTexture("Camera",e,t,a);"Chrome"!==MDBrowser&&"Safari"!==MDBrowser||(console.log("open float map"),a.elType=TextureElemType.float),a.hasMipMap=!1;t=b.createDefaultCamera(e/t);return t.setFov(90),t.setNear(.1),t.clearColor=[1,0,0,1],t.transform.setPosition(0,0,0),t.renderTarget=a,t.renderMask=v.layers,t.addRenderLayer(r),t}static createRenderSphere(e,t){var r=e.scene,i=e.envCam,a=e.layer,o=e.pos,s=e.namePrefix,n=e.reqCam;if(void 0===s&&(s="dft"),void 0===o&&(o=new P(0,0,0)),void 0!==a&&void 0!==r&&void 0!==i){var e=s+"entity",l=me.createEntity(r,e,t);i.name=s+"Cam",i.renderTarget.name=s+"Tex",l.material.name=s+"Mat",l.finishShot=!1,l.setRenderLayer(a),l.transform.setPosition(o.x,o.y,o.z),i.transform.setPosition(o.x,o.y,o.z);var h={loaded:!1,startShot:!1};return 0===l.material.texList.length&&(noTex=!0),i.afterDrawFunc=function(e,t){var r,a=0===l.material.texList.length||l.material.texPrepared;a&&i.renderTarget.type===TextureType.cube&&(0===i.renderTarget.currentFace&&(h.startShot=!0,console.log("start take shot >>>",i.name)),r=!0,(r=void 0!==n?n.finishShot:r)&&h.startShot&&5===i.renderTarget.currentFace&&(i.enable=!1,i.finishShot=!0,i.renderTarget.generateMipMap(e),console.log("close camera>>>",i.name),_.isNone(i.next)||(i.next.enable=!0,console.log("open camera>>>",i.next.name)),h.startShot=!1)),a&&i.renderTarget.type===TextureType.default&&(a=!0,(a=void 0!==n?n.finishShot:a)&&h.startShot&&(i.enable=!1,i.finishShot=!0,console.log("close camera>>>",i.name),_.isNone(i.next)||(i.next.enable=!0,console.log("open camera>>>",i.next.name))),a&&(h.startShot=!0))},l}console.log("we need information of layer, scene, envCam")}static createRadianceCamera(e,t,r,a,i,o){a=ve.createCubeCamera(r,a,i);a.renderTarget.hasMipMap=!0,o.addCamera(a);e=ve.createRenderSphere({scene:o,envCam:a,layer:i,namePrefix:"cube_rad"},{mesh:t,material:e});return o.addEntity(e),a.envSphere=e,a}}class ge{static registerMovehandler(e,t,r,a){var i={sx:-1,sy:-1,px:-1,py:-1,width:e.clientWidth,height:e.clientHeight,range:r=void 0===r?[360,180]:r,state:-1};e.addEventListener("touchmove",function(e){ge.responseToTouchRot(e,t,1,i,a)},!1),e.addEventListener("touchstart",function(e){ge.responseToTouchRot(e,t,0,i)},!1),e.addEventListener("touchend",function(e){ge.responseToTouchRot(e,t,2,i)},!1),e.addEventListener("mousemove",function(e){ge.responseToMouseRot(e,t,1,i,a)},!1),e.addEventListener("mousedown",function(e){ge.responseToMouseRot(e,t,0,i)},!1),e.addEventListener("mouseup",function(e){ge.responseToMouseRot(e,t,2,i)},!1)}static responseToMouseRot(e,t,r,a,i){switch(r){case 0:a.state=0,a.sx=e.clientX,a.sy=e.clientY,a.px=e.clientX,a.py=e.clientY;break;case 1:var o,s;0===a.state&&(o=(e.clientX-a.px)/a.width,s=(e.clientY-a.py)/a.height,o=o*a.range[0],s=s*a.range[1],t.rotate(s,o,0),null!=i&&i(t),a.px=e.clientX,a.py=e.clientY);break;case 2:a.state=2}}static responseToTouchRot(e,t,r,a,i){var o=e.touches[0];switch(r){case 0:a.sx=o.clientX,a.sy=o.clientY,a.px=o.clientX,a.py=o.clientY;break;case 1:var s=(o.clientX-a.px)/a.width,n=(o.clientY-a.py)/a.height,s=s*a.range[0],n=n*a.range[1];t.rotate(n,s,0),null!=i&&i(t),a.px=o.clientX,a.py=o.clientY}}static registerCameraMove(a,e,i){a.transform.rotOrder=s.zyx;var o=new P(a.transform.pos.x,a.transform.pos.y,a.transform.pos.z);ge.registerMovehandler(e,a.transform,[360,45],function(e){var t=Math.sqrt(o.x*o.x+o.y*o.y+o.z*o.z),r=e.rot.x*Math.PI/180;e.pos.y=-1*t*Math.sin(r);t=+t*Math.cos(r),r=e.rot.y*Math.PI/180;e.pos.x=t*Math.sin(r),e.pos.z=t*Math.cos(r),_.isNone(i)||i(a.transform)})}}class xe extends t{constructor(){super(),this.urls=[],this.loadCount=0,this.res=null}loadByHttp(e,t){var r=new XMLHttpRequest;r.onreadystatechange=function(){var e;4===r.readyState&&(200!==r.status&&0!==r.status||(e=r.responseText,t(e)))},r.open("GET",e,!0),r.send()}load(e,t,r){e instanceof Array?this.urls=e:this.urls[0]=e,this.count=this.urls.length;function a(e){e=(new(AssetsManager.getManager().getParser(o.urls[i]))).parse(e,t),null===o.res?o.res=e:o.res.push.apply(o.res,e),o.count--,null!==r&&0===o.count&&r(o.res)}var i,o=t.asset=this;for(i in this.urls)this.loadByHttp(this.urls[i],a)}}class ye extends se{constructor(e,t,r,a){super(e,t,r,a),this.depthRBuffer=null,this.hasColorBuffer=!0,this.frameBufferId=null,this.assitColorBuffers=null,this.currentFace=-1,this.currentMip=0}loadTexture(e,t){var r;this.hasColorBuffer?(this.depthRBuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,this.depthRBuffer),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_STENCIL,this.width,this.height)):(r=e.getExtension("WEBGL_depth_texture"),console.log(r),super.format="DEPTH_COMPONENT",super.elType="UNSIGNED_SHORT",this.hasMipMap=!1),this.frameBufferId=e.createFramebuffer(),this.elType===TextureElemType.float&&e.getExtension("WEBGL_color_buffer_float"),this.wrap_mode=TextureWrap.default,super.loadTexture(e,t),this.loadAssitColorBuffers(e)}loadAssitColorBuffers(e){if(null!==this.assitColorBuffers)for(var t=0;t<this.assitColorBuffers.length;t++)this.assitColorBuffers[t].loadTexture(e,null)}uploadColorBuffers(e){var t=e.TEXTURE_2D;if(this.type===TextureType.cube&&(t=e.TEXTURE_CUBE_MAP_POSITIVE_X+this.currentFace),null!==this.assitColorBuffers){var r=e.getExtension("WEBGL_draw_buffers");e.framebufferTexture2D(e.FRAMEBUFFER,r.COLOR_ATTACHMENT0_WEBGL,t,this.glTexture,this.currentMip);for(var a=[r.COLOR_ATTACHMENT0_WEBGL],i=0;i<this.assitColorBuffers.length;i++){var o=this.assitColorBuffers[i],s=r["COLOR_ATTACHMENT"+(i+1)+"_WEBGL"];a.push(s),e.framebufferTexture2D(e.FRAMEBUFFER,s,t,o.glTexture,this.currentMip),this.onFrameLoaded(o)}r.drawBuffersWEBGL(a)}else e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,t,this.glTexture,this.currentMip)}generateMipMap(e){var t;this.hasMipMap&&(t=e[this.type],e.bindTexture(t,this.glTexture),e.generateMipmap(t),e.bindTexture(t,null),console.log("produce mipmap"))}onFrameLoaded(e){e.state!==LoadState.loading||e.type===TextureType.cube&&5!==e.currentFace||(e.state=LoadState.loaded,TextureManager.getManager().onTexLoaded(e))}calRotateFace(e){5===this.currentFace&&(this.currentFace=-1),this.currentFace+=1;var t=new P(0,0,0);switch(e.transform.resetRotate(0,0,0),this.currentFace){case 0:t.y=90,t.x=180;break;case 1:t.y=-90,t.x=180;break;case 2:t.x=90;break;case 3:t.x=-90;break;case 4:t.z=180,t.y=-180;break;case 5:t.z=180}e.transform.rotate(t.x,t.y,t.z)}updateFBODate(e,t){this.type===TextureType.cube&&this.calRotateFace(t),this.hasColorBuffer?(this.uploadColorBuffers(e),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.RENDERBUFFER,this.depthRBuffer),e.bindRenderbuffer(e.RENDERBUFFER,null)):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,this.glTexture,0),this.onFrameLoaded(this)}}return e.Asset=r,e.AssetsManager=a,e.AttributeType=u,e.Camera=C,e.CameraType=L,e.CameraUtil=b,e.CanvasUtil=S,e.ClearMask=T,e.DefaultUniformKey=c,e.DirectionLight=z,e.Entity=M,e.GridMesh=A,e.IAsset=t,e.IBLUtil=ve,e.ImgLoader=oe,e.InteractUtil=ge,e.Light=V,e.LightUtil=G,e.MacroAsset=xe,e.Material=W,e.MaterialAni=function(r,a,i,o){var s=o.update;return o.update=function(e){var t=o.targets[i];"number"==typeof t&&a.setUniform(i,UTypeEnumn.float,t),a.uDirty=!0,r.requireUpdate(),s(e)},anime(o)},e.MaterialUtil=de,e.MathUtil=_,e.Mesh=E,e.MeshUtil=B,e.Pass=X,e.PassLayer=H,e.PointLight=O,e.PrimitiveType=I,e.Program=m,e.ProgramInfo=p,e.Render=y,e.RenderInfo=x,e.RenderLayer=g,e.RenderMask=v,e.RenderTexture=ye,e.RotationOrder=s,e.Scene=pe,e.SceneUtil=me,e.ShaderLayer=class{constructor(){this.passList=[]}},e.ShaderOption=n,e.SubPass=k,e.Texture=se,e.TextureBlend=ie,e.TextureManager=q,e.Transform=h,e.TransformAni=function(t,r,e){var a=e.update;return e.update=function(e){r.requireUpdate(),t.requireUpdate(),a(e)},anime(e)},e.UTypeEnumn=w,e.ValueAni=function(e){var t=e.update;return e.update=function(e){t(e)},anime(e)},e.Vector3=P,e.Vector4=l,e.VertexBuffer=R,Object.defineProperty(e,"__esModule",{value:!0}),e}({});
